/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "./stencil-public-runtime";
import { AccordionExpand } from "./components/accordion/accordion.model";
import { ActionBarAlignment, ActionBarSize } from "./components/action-bar/action-bar.model";
import { AlertColors, AlertTypes } from "./components/alert/alert.model";
import { AvatarSize, AvatarType } from "./components/avatar/avatar.model";
import { BadgeColorTypes, BadgePositions, BadgeTypes } from "./components/badge/badge.model";
import { ButtonColors, ButtonIconPositions, ButtonSizes, ButtonTypes } from "./components/button/button.model";
import { ButtonExpandableSizesType } from "./components/button-expandable/button-expandable.model";
import { ButtonLinkColors, ButtonLinkPositions, ButtonLinkSizes } from "./components/button-link/button-link.model";
import { CalendarColor, CalendarType } from "./components/calendar/calendar.model";
import { CardOrientations, CardSizes } from "./components/card/card.model";
import { CardSelectableSizes, CardSelectableTypes } from "./components/card-selectable/card-selectable.model";
import { CardSelectableGroupSizes } from "./components/card-selectable/card-selectable-group/card-selectable-group.model";
import { ThumbnailTypes } from "./components/card/card-thumbnail/card-thumbnail.model";
import { CheckboxChangeEventDetail, CheckboxValues, FeedbackTypes } from "./components/checkbox/checkbox.model";
import { FeedbackTypes as FeedbackTypes1 } from "./components/checkbox/checkbox-group/checkbox-group.model";
import { ChipChoiceSizes } from "./components/chip-choice/chip-choice.model";
import { ChipDismissSizes } from "./components/chip-dismiss/chip-dismiss.model";
import { DatepickerColor, DatepickerFeedback, DatepickerSize, DatepickerType } from "./components/datepicker/datepicker.model";
import { DatepickerRangeColor, DatepickerRangeFeedback, DatepickerRangeSize, DatepickerRangeType } from "./components/datepicker-range/datepicker-range.model";
import { DividerColorType, DividerOrientationType, DividerSizeType } from "./components/divider/divider.model";
import { ActionListItem, dropdownFeedbackTypes, dropdownSizes } from "./components/dropdown/dropdown.model";
import { EmptyStateTypes, HeadingSizes } from "./components/empty-state/empty-state.model";
import { IconSizeTypes } from "./utils/helper";
import { IconColorTypes } from "./components/icon/icon.model";
import { InputCounterFeedbackType, InputCounterSize } from "./components/input-counter/input-counter.model";
import { InputPasswordAutocomplete } from "./components/input-password/input-password.models";
import { InputSize, InputTextType } from "./components/input-text/input-text.model";
import { InputSize as InputSize1 } from "./components/input-textarea/input-textarea.models";
import { linkSizes, linkTargets } from "./components/link/link.model";
import { ListLinkTargetType, ListOrientationType, ListSizeType } from "./components/list/list.model";
import { Alignments } from "./components/menu-button/menu-button.model";
import { ButtonColors as ButtonColors1, ButtonSizes as ButtonSizes1 } from "./components/button/button.model";
import { MenuHorizontalItem } from "./components/menu-horizontal/menu-horizontal-item/menu-horizontal-item.model";
import { TargetTypes } from "./components/menu-horizontal/menu-horizontal.model";
import { MenuLateralItem } from "./components/menu-lateral/menu-lateral.model";
import { MenuVerticalAppearance } from "./components/menu-vertical/menu-vertical.model";
import { MenuItem } from "./components/menu-vertical/stories/menu-vertical.types";
import { menuItemLinkTarget } from "./components/menu-vertical/menu-vertical-item-link/menu-vertical-item-link.model";
import { ModalAppearanceType, ModalSizeType } from "./components/modal/modal.model";
import { PictogramSizeTypes } from "./components/pictogram/pictogram.model";
import { ProgressBarLabelAlignmentType } from "./components/progress-bar/progress-bar.model";
import { RadioButtonChangeDetail } from "./components/radio-button/radio-button.model";
import { FeedbackType, OrientationType } from "./components/radio-button/radio-button-group/radio-button-group.model";
import { HeadingSizes as HeadingSizes1, SectionTitleColorType, SectionTitleOptionType } from "./components/section-title/section-title.model";
import { SegmentedControlColor, SegmentedControlFeedback, SegmentedControlItemChangeSelect, SegmentedControlItemIconPosition, SegmentedControlSize, SegmentedControlType } from "./components/segmented-control/segmented-control.model";
import { SliderFeedbackErrorCounterType, SliderFeedbackType, SliderType } from "./components/slider/slider.model";
import { StepAlignmentType, StepFeedbackType, StepRoleType, StepSizeType } from "./components/stepper/step/step-model";
import { StepperOrientationType, StepperSizeType } from "./components/stepper/stepper-model";
import { SwitchChangeDetail } from "./components/switch/switch.model";
import { TableAlignmentType, TableClickEvent, TableColorType, TableFrozenType, TableRowClickEvent, TableRowSelectionChangeEvent, TableSelectableType, TableSelectAllChangeEvent, TableSelectionChangeEvent, TableSizeType, TableStripingType } from "./components/table/table.model";
import { TabItem, TabsType } from "./components/tabs/tabs.model";
import { TagColorTypes, TagSizes } from "./components/tag/tag.model";
import { AthTextColor, AthTextColumns } from "./components/text/text.model";
import { TooltipColors, TooltipPositions, TooltipTriggers } from "./components/tooltip/tooltip.model";
import { UserDetailType } from "./components/user/user-detail/user-detail.model";
import { UserMenuType } from "./components/user/user-menu/user-menu.model";
export { AccordionExpand } from "./components/accordion/accordion.model";
export { ActionBarAlignment, ActionBarSize } from "./components/action-bar/action-bar.model";
export { AlertColors, AlertTypes } from "./components/alert/alert.model";
export { AvatarSize, AvatarType } from "./components/avatar/avatar.model";
export { BadgeColorTypes, BadgePositions, BadgeTypes } from "./components/badge/badge.model";
export { ButtonColors, ButtonIconPositions, ButtonSizes, ButtonTypes } from "./components/button/button.model";
export { ButtonExpandableSizesType } from "./components/button-expandable/button-expandable.model";
export { ButtonLinkColors, ButtonLinkPositions, ButtonLinkSizes } from "./components/button-link/button-link.model";
export { CalendarColor, CalendarType } from "./components/calendar/calendar.model";
export { CardOrientations, CardSizes } from "./components/card/card.model";
export { CardSelectableSizes, CardSelectableTypes } from "./components/card-selectable/card-selectable.model";
export { CardSelectableGroupSizes } from "./components/card-selectable/card-selectable-group/card-selectable-group.model";
export { ThumbnailTypes } from "./components/card/card-thumbnail/card-thumbnail.model";
export { CheckboxChangeEventDetail, CheckboxValues, FeedbackTypes } from "./components/checkbox/checkbox.model";
export { FeedbackTypes as FeedbackTypes1 } from "./components/checkbox/checkbox-group/checkbox-group.model";
export { ChipChoiceSizes } from "./components/chip-choice/chip-choice.model";
export { ChipDismissSizes } from "./components/chip-dismiss/chip-dismiss.model";
export { DatepickerColor, DatepickerFeedback, DatepickerSize, DatepickerType } from "./components/datepicker/datepicker.model";
export { DatepickerRangeColor, DatepickerRangeFeedback, DatepickerRangeSize, DatepickerRangeType } from "./components/datepicker-range/datepicker-range.model";
export { DividerColorType, DividerOrientationType, DividerSizeType } from "./components/divider/divider.model";
export { ActionListItem, dropdownFeedbackTypes, dropdownSizes } from "./components/dropdown/dropdown.model";
export { EmptyStateTypes, HeadingSizes } from "./components/empty-state/empty-state.model";
export { IconSizeTypes } from "./utils/helper";
export { IconColorTypes } from "./components/icon/icon.model";
export { InputCounterFeedbackType, InputCounterSize } from "./components/input-counter/input-counter.model";
export { InputPasswordAutocomplete } from "./components/input-password/input-password.models";
export { InputSize, InputTextType } from "./components/input-text/input-text.model";
export { InputSize as InputSize1 } from "./components/input-textarea/input-textarea.models";
export { linkSizes, linkTargets } from "./components/link/link.model";
export { ListLinkTargetType, ListOrientationType, ListSizeType } from "./components/list/list.model";
export { Alignments } from "./components/menu-button/menu-button.model";
export { ButtonColors as ButtonColors1, ButtonSizes as ButtonSizes1 } from "./components/button/button.model";
export { MenuHorizontalItem } from "./components/menu-horizontal/menu-horizontal-item/menu-horizontal-item.model";
export { TargetTypes } from "./components/menu-horizontal/menu-horizontal.model";
export { MenuLateralItem } from "./components/menu-lateral/menu-lateral.model";
export { MenuVerticalAppearance } from "./components/menu-vertical/menu-vertical.model";
export { MenuItem } from "./components/menu-vertical/stories/menu-vertical.types";
export { menuItemLinkTarget } from "./components/menu-vertical/menu-vertical-item-link/menu-vertical-item-link.model";
export { ModalAppearanceType, ModalSizeType } from "./components/modal/modal.model";
export { PictogramSizeTypes } from "./components/pictogram/pictogram.model";
export { ProgressBarLabelAlignmentType } from "./components/progress-bar/progress-bar.model";
export { RadioButtonChangeDetail } from "./components/radio-button/radio-button.model";
export { FeedbackType, OrientationType } from "./components/radio-button/radio-button-group/radio-button-group.model";
export { HeadingSizes as HeadingSizes1, SectionTitleColorType, SectionTitleOptionType } from "./components/section-title/section-title.model";
export { SegmentedControlColor, SegmentedControlFeedback, SegmentedControlItemChangeSelect, SegmentedControlItemIconPosition, SegmentedControlSize, SegmentedControlType } from "./components/segmented-control/segmented-control.model";
export { SliderFeedbackErrorCounterType, SliderFeedbackType, SliderType } from "./components/slider/slider.model";
export { StepAlignmentType, StepFeedbackType, StepRoleType, StepSizeType } from "./components/stepper/step/step-model";
export { StepperOrientationType, StepperSizeType } from "./components/stepper/stepper-model";
export { SwitchChangeDetail } from "./components/switch/switch.model";
export { TableAlignmentType, TableClickEvent, TableColorType, TableFrozenType, TableRowClickEvent, TableRowSelectionChangeEvent, TableSelectableType, TableSelectAllChangeEvent, TableSelectionChangeEvent, TableSizeType, TableStripingType } from "./components/table/table.model";
export { TabItem, TabsType } from "./components/tabs/tabs.model";
export { TagColorTypes, TagSizes } from "./components/tag/tag.model";
export { AthTextColor, AthTextColumns } from "./components/text/text.model";
export { TooltipColors, TooltipPositions, TooltipTriggers } from "./components/tooltip/tooltip.model";
export { UserDetailType } from "./components/user/user-detail/user-detail.model";
export { UserMenuType } from "./components/user/user-menu/user-menu.model";
export namespace Components {
    interface AthAccordion {
        /**
          * Indica una etiqueta accesible para el acordeón
         */
        "ariaLabel": string | null;
        /**
          * Indica si se pueden abrir todos los elementos al mismo tiempo
          * @default AccordionExpands.All
         */
        "expand": AccordionExpand;
        /**
          * Si es true, se muestra el divisor también en el último ítem.
          * @default false
         */
        "noLastItemDivider": boolean;
    }
    interface AthAccordionItem {
        "close": () => Promise<void>;
        /**
          * Descriprion of heading item
         */
        "description": string;
        /**
          * The accordion item is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * The accordion item is expanded
          * @default false
         */
        "expanded": boolean;
        /**
          * The accordion item aria-level
          * @default '2'
         */
        "headingLevel": string;
        /**
          * Title of heading item
         */
        "headingText": string;
        /**
          * The code of the accordion item's icon
         */
        "icon": string;
        /**
          * The accordion item divider bottom
          * @default false
         */
        "noDivider": boolean;
    }
    interface AthActionBar {
        /**
          * Indicates the alignment of the inner components
          * @default ActionBarAlignments.Left
         */
        "alignment": ActionBarAlignment;
        /**
          * Indicates the size of the inner components
          * @default ActionBarSizes.Medium
         */
        "size": ActionBarSize;
    }
    interface AthAlert {
        /**
          * Close button aria-label
          * @default 'Cerrar alerta'
         */
        "closeAriaLabel": string;
        /**
          * The color of the message
          * @default AlertColor.Info
         */
        "color": AlertColors;
        /**
          * Descripcion del alert
         */
        "description"?: string;
        /**
          * Has button close
          * @default true
         */
        "hasClose": boolean;
        /**
          * Nivel de heading del título
          * @default 6
         */
        "headingLevel": number;
        /**
          * Titulo del alert
         */
        "headingText"?: string;
        /**
          * Titulo del alert
          * @default false
         */
        "isUrgent"?: boolean;
        /**
          * Tipo de alert
          * @default AlertType.Section
         */
        "type": AlertTypes;
    }
    interface AthAvatar {
        /**
          * The aria-labelledby attribute of the icon
         */
        "ariaLabelledby"?: string;
        /**
          * Name used to generate initials if none are provided.
         */
        "avatarName": string;
        /**
          * Initials to display in the avatar.
         */
        "initials": string;
        /**
          * Size of the avatar.
          * @default AvatarSizes.Medium
         */
        "size": AvatarSize;
        /**
          * Type of avatar (image or initials).
         */
        "type": AvatarType;
    }
    interface AthBadge {
        /**
          * Badge color accompanying the purpose of the message
          * @default BADGE_DEFAULT_COLOR
         */
        "color": BadgeColorTypes;
        /**
          * Custom horizontal distance of the badge from its default position
          * @default 0
         */
        "distanceX": number;
        /**
          * Custom vertical distance of the badge from its default position
          * @default 0
         */
        "distanceY": number;
        /**
          * Accessibility label describing the message
         */
        "label": any;
        /**
          * Value from which a + will be added once exceeded by the "value"
          * @default MAX_VALUE
         */
        "max": number;
        /**
          * Positioning of the badge relative to the slot
         */
        "position": BadgePositions;
        /**
          * The badge can display a value or be a decorative element
          * @default BADGE_DEFAULT_TYPE
         */
        "type": BadgeTypes;
        /**
          * Value displayed within the badge if it is "numeric"
          * @default 0
         */
        "value": number;
    }
    interface AthBreadcrumb {
        /**
          * Definición de un aria-label personalizado para el breadcrumb
         */
        "athAriaLabel"?: string;
        /**
          * Si es true y el breadcrumb tiene más de 4 elementos, el breadcrumb se renderiza colapsado.  Al hacer click en "..." este valor se alterna.
          * @default false
         */
        "collapsed": boolean;
        /**
          * Lista de enlaces del breadcrumb. Normalmente se recibe como un string JSON desde HTML.
         */
        "options": any;
        /**
          * Separador entre los enlaces del breadcrumb
          * @default '/'
         */
        "separator": string;
    }
    interface AthButton {
        /**
          * The clear of the button (background and border color)
          * @default false
         */
        "clear": boolean;
        /**
          * The color variant of the button
          * @default ButtonColor.Primary
         */
        "color": ButtonColors;
        /**
          * The button is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * The button can be adapted to its container width
          * @default false
         */
        "fullWidth": boolean;
        /**
          * The code of the button's icon (used with iconPosition)
         */
        "icon": string;
        /**
          * Whether the button has an icon and his position
          * @default ButtonIconPosition.None
         */
        "iconPosition": ButtonIconPositions;
        "setFocus": () => Promise<void>;
        /**
          * The size of the buton
          * @default ButtonSize.Medium
         */
        "size": ButtonSizes;
        /**
          * The type of the button
          * @default ButtonType.Button
         */
        "type": ButtonTypes;
    }
    interface AthButtonExpandable {
        "collapseTarget": string;
        /**
          * The button is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * The code of the button's icon (used with iconPosition)
         */
        "icon": string;
        "setFocus": () => Promise<void>;
        /**
          * The size of the buton
          * @default ButtonExpandableSizesTypes.Large
         */
        "size": ButtonExpandableSizesType;
    }
    interface AthButtonLink {
        /**
          * The color variant of the button-link
          * @default ButtonLinkColor.Primary
         */
        "color": ButtonLinkColors;
        /**
          * The button-link is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * The code of the button-link's icon
         */
        "icon": string;
        /**
          * Icon Position
          * @default ButtonLinkPosition.Left
         */
        "iconPosition": ButtonLinkPositions;
        "setFocus": () => Promise<void>;
        /**
          * The size of the buton-link
          * @default ButtonLinkSize.Medium
         */
        "size": ButtonLinkSizes;
    }
    interface AthCalendar {
        /**
          * The color of the Calendar.
          * @default CalendarColors.Primary
         */
        "color": CalendarColor;
        /**
          * List of days which are shown as disabled.
         */
        "disabledDates": string;
        /**
          * List of days which are shown as highlighted.
         */
        "highlightedDates": string;
        /**
          * If true, all the weekends will be highlighted.
          * @default false
         */
        "highlightedWeekends": boolean;
        /**
          * The maximum date that can be selected.
         */
        "max"?: string;
        /**
          * The minimum date that can be selected.
         */
        "min"?: string;
        "selected"?: string;
        /**
          * The type of the Calendar.
          * @default CalendarTypes.Date
         */
        "type": CalendarType;
    }
    interface AthCard {
        /**
          * ancho máximo de la card
         */
        "ariaLabelledBy": string;
        /**
          * Card is clickable
          * @default false
         */
        "clickable": boolean;
        /**
          * if Card thumbnail is fluid
          * @default false
         */
        "fluid": boolean;
        /**
          * ancho máximo de la card
         */
        "maxWidth": string;
        /**
          * Orientation Card
          * @default CardOrientation.Vertical
         */
        "orientation": CardOrientations;
        /**
          * Size of the card
          * @default CardSize.Small
         */
        "size": CardSizes;
        /**
          * ancho de la card
         */
        "width": string;
    }
    interface AthCardHeader {
        /**
          * date of the card header
         */
        "date": string;
        /**
          * Title of the card header
         */
        "headingText": string;
        /**
          * Overline of the card header
         */
        "overline": string;
        /**
          * Subtitle of the card
         */
        "subtitle": string;
    }
    interface AthCardSelectable {
        /**
          * Indicates whether the card is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * headline of the card
         */
        "headingText": string;
        /**
          * overline of the card
         */
        "overline": string;
        "select": (firstLoad: boolean) => Promise<void>;
        /**
          * Indicates whether the card is selected
          * @default false
         */
        "selected": boolean;
        /**
          * Size of the card
          * @default CardSelectableSize.Small
         */
        "size": CardSelectableSizes;
        /**
          * subtitle of the card
         */
        "subtitle": string;
        /**
          * tag of the card
         */
        "tag": string;
        /**
          * type of card
          * @default CardSelectableType.Single
         */
        "type": CardSelectableTypes;
        "unselect": () => Promise<void>;
    }
    interface AthCardSelectableGroup {
        /**
          * Indicates whether the card selectable group is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Indicates whether the group is multi selection
          * @default false
         */
        "multiple": boolean;
        /**
          * Size for the cards
          * @default CardSelectableGroupSize.Small
         */
        "size": CardSelectableGroupSizes;
    }
    interface AthCardThumbnail {
        /**
          * Text for bottom tag
         */
        "bottomTag": string;
        /**
          * text highlight
         */
        "highlightText": string;
        /**
          * Text for top tag
         */
        "topTag": string;
        /**
          * type of thumnail
          * @default ThumbnailType.Default
         */
        "type": ThumbnailTypes;
        "updateTypeCard": (isFluid: boolean, isVertical: boolean) => Promise<void>;
    }
    interface AthCheckbox {
        /**
          * Accessible text when there is no visible label
         */
        "ariaLabel": string | null;
        /**
          * If the element is focused
          * @default false
         */
        "autofocus": boolean;
        /**
          * If the checkbox is checked by default
          * @default false
         */
        "checked": boolean;
        /**
          * If it is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Type of feedback
          * @default FeedbackType.None
         */
        "feedback": FeedbackTypes;
        /**
          * Text of the feedback
         */
        "feedbackText": string;
        /**
          * Text below the checkbox (helper text)
         */
        "helperText": string;
        /**
          * If the required character is shown in the label
          * @default false
         */
        "hideRequired": boolean;
        /**
          * If the checkbox is indeterminate by default
          * @default false
         */
        "indeterminate": boolean;
        /**
          * Label of the checkbox
         */
        "label": string;
        /**
          * Name of the checkbox (necessary for forms)
         */
        "name": string;
        /**
          * If it is read-only
          * @default false
         */
        "readonly": boolean;
        /**
          * If it is required
          * @default false
         */
        "required": boolean;
        "setFocus": () => Promise<void>;
        /**
          * Value of the checkbox
          * @default CheckboxValue.False
         */
        "value": CheckboxValues;
    }
    interface AthCheckboxGroup {
        /**
          * Indica si esta deshabilitado
          * @default false
         */
        "disabled": boolean;
        /**
          * Indica el tipo de feedback
          * @default FeedbackType.None
         */
        "feedback": FeedbackTypes1;
        /**
          * Texto feedback
         */
        "feedbackText": string;
        /**
          * Texto ayuda
         */
        "helperText": string;
        /**
          * Texto para el Label
         */
        "label": string;
        /**
          * Atributo name a aplicar a todo el grupo
         */
        "name": string;
        /**
          * Indica si es solo lectura
          * @default false
         */
        "readonly": boolean;
        /**
          * Texto oculto para lectores de pantalla indicando que el grupo es requerido
         */
        "requiredAriaLabel": string;
        /**
          * Indica si se muestra el asterisco
          * @default false
         */
        "showRequired": boolean;
        /**
          * Indica el texto del tooltip
         */
        "tooltipText": string;
        /**
          * Indica el ancho de la burbuja tooltip
          * @default 0
         */
        "tooltipWidth": number;
    }
    interface AthChipChoice {
        /**
          * Indica si el chip esta deshabilitado
          * @default false
         */
        "disabled": boolean;
        /**
          * Indica el nombre del icono a usar
         */
        "icon": string;
        /**
          * Texto del chip
         */
        "label": string;
        /**
          * The chip name for HTML Form API
         */
        "name": string;
        /**
          * The role of the chip
          * @default ChipChoiceRole.Checkbox
         */
        "role": string | null;
        "select": () => Promise<void>;
        /**
          * Indica si el chip esta seleccionado
          * @default false
         */
        "selected": boolean;
        /**
          * Indica el tamaño del chip (sm/md)
          * @default ChipChoiceSize.Medium
         */
        "size": ChipChoiceSizes;
        "unselect": () => Promise<void>;
        /**
          * The chip value for HTML Form API
         */
        "value": string;
    }
    interface AthChipChoiceGroup {
        /**
          * Weather the chips are disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Allow multiple selection of chips
          * @default false
         */
        "multiple": boolean;
        /**
          * The generic name for the chips
         */
        "name": string;
        /**
          * The generic size of the chips
          * @default ChipChoiceSize.Medium
         */
        "size": ChipChoiceSizes;
        /**
          * The value for not multiple (use chip-choice-group as radio-group)
         */
        "value": string;
        /**
          * The width of the group
         */
        "width": string;
    }
    interface AthChipDismiss {
        /**
          * The button is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * The text in the chip
         */
        "headingText": string;
        /**
          * The icon to the left
         */
        "icon": string;
        /**
          * The accesible label-dismiss attribute in chip dismiss
          * @default 'Eliminar'
         */
        "labelDismiss": string;
        /**
          * The size of the chip dismiss
          * @default ChipDismissSize.Medium
         */
        "size": ChipDismissSizes;
    }
    interface AthChipDismissGroup {
        /**
          * Weather the chips are disabled
         */
        "disabled": boolean;
        /**
          * The generic size of the chips
          * @default ChipDismissSize.Medium
         */
        "size": ChipDismissSizes;
        /**
          * The width of the group
         */
        "width": string;
    }
    interface AthCollapse {
        /**
          * If the component is expanded by default
          * @default false
         */
        "show": boolean;
    }
    interface AthCollapseIcon {
        /**
          * Current expanded state
          * @default false
         */
        "expanded": boolean;
    }
    interface AthDatepicker {
        /**
          * Whether the datepicker is focused on page load.
         */
        "autofocus": boolean;
        /**
          * The color of the datepicker.
          * @default DatepickerColors.Primary
         */
        "color": DatepickerColor;
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled": boolean;
        /**
          * List of days which are shown as disabled.
         */
        "disabledDates": string;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown
          * @default DatepickerFeedbacks.None
         */
        "feedback": DatepickerFeedback;
        /**
          * The feedback message.
         */
        "feedbackText": string;
        /**
          * Date format to be used in the datepicker. Only used when the type is 'date'.
          * @default 'DD/MM/YYYY'
         */
        "format": string;
        /**
          * Message to help the user fills the datepicker.
         */
        "helperText": string;
        /**
          * If true, the * asterisk will be show when required = true.
          * @default false
         */
        "hideRequired": boolean;
        /**
          * List of days which are shown as highlighted.
         */
        "highlightedDates": string;
        /**
          * If true, all the weekends will be highlighted.
          * @default false
         */
        "highlightedWeekends": boolean;
        /**
          * The aria-label attribute of the input
         */
        "inputAriaLabel": string;
        /**
          * Caption of the datepicker
         */
        "label": string;
        /**
          * The maximum date that can be selected.
         */
        "max"?: string;
        /**
          * The minimum date that can be selected.
         */
        "min"?: string;
        /**
          * The name of the datepicker. Submitted with the form as part of a name/value pair
         */
        "name": string;
        "placeholder": string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly": boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required": boolean;
        /**
          * Method to set the focus on the input element
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the datepicker.
          * @default DatepickerSizes.Medium
         */
        "size": DatepickerSize;
        /**
          * If true, submit the form when pressing Enter in the input field and the input is inside a form
          * @default false
         */
        "submitOnEnter": boolean;
        /**
          * Text to be shown in the tooltip
         */
        "tooltipText": string;
        /**
          * The type of the datepicker.
          * @default DatepickerTypes.Date
         */
        "type": DatepickerType;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value": string;
    }
    interface AthDatepickerRange {
        /**
          * Whether the datepicker is focused on page load.
         */
        "autofocus": boolean;
        /**
          * The color of the datepicker-range.
          * @default DatepickerRangeColors.Primary
         */
        "color": DatepickerRangeColor;
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled": boolean;
        /**
          * List of days which are shown as disabled.
         */
        "disabledDates": string;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown
          * @default DatepickerRangeFeedbacks.None
         */
        "feedback": DatepickerRangeFeedback;
        /**
          * The feedback message.
         */
        "feedbackText": string;
        /**
          * Date format to be used in the datepicker-range. Only used when the type is 'date'.
          * @default 'DD/MM/YYYY'
         */
        "format": string;
        /**
          * Message to help the user fills the datepicker-range.
         */
        "helperText": string;
        /**
          * If true, the side panel will be hidden.
          * @default false
         */
        "hidePanel": boolean;
        /**
          * If true, the * asterisk will be show when required = true.
          * @default false
         */
        "hideRequired": boolean;
        /**
          * List of days which are shown as highlighted.
         */
        "highlightedDates": string;
        /**
          * If true, all the weekends will be highlighted.
          * @default false
         */
        "highlightedWeekends": boolean;
        /**
          * The aria-label attribute of the end input
         */
        "inputAriaLabelEnd": string;
        /**
          * The aria-label attribute of the start input
         */
        "inputAriaLabelStart": string;
        /**
          * Caption of the datepicker-range
         */
        "label": string;
        /**
          * Caption of the datepicker-range
         */
        "labelEnd": string;
        /**
          * Caption of the range start of the datepicker-range
         */
        "labelStart": string;
        /**
          * The maximum date that can be selected.
         */
        "max"?: string;
        /**
          * The minimum date that can be selected.
         */
        "min"?: string;
        /**
          * The name of the datepicker-range. Submitted with the form as part of a name/value pair
         */
        "name": string;
        "placeholderEnd": string;
        "placeholderStart": string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly": boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required": boolean;
        /**
          * If true, the user must fill in a value of end range before submitting a form.
          * @default false
         */
        "requiredEnd": boolean;
        /**
          * If true, the user must fill in a value of start range before submitting a form.
          * @default false
         */
        "requiredStart": boolean;
        /**
          * Method to set the focus on the input element
         */
        "setFocus": () => Promise<void>;
        /**
          * Method to set the focus on the second input element
         */
        "setFocusEnd": () => Promise<void>;
        /**
          * The size of the datepicker-range.
          * @default DatepickerRangeSizes.Medium
         */
        "size": DatepickerRangeSize;
        /**
          * If true, submit the form when pressing Enter in the input field and the input is inside a form
          * @default false
         */
        "submitOnEnter": boolean;
        /**
          * Text to be shown in the tooltip
         */
        "tooltipText": string;
        /**
          * The type of the datepicker-range.
          * @default DatepickerRangeTypes.Date
         */
        "type": DatepickerRangeType;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value": string;
    }
    interface AthDivider {
        /**
          * Color of the divider
          * @default DIVIDER_DEFAULT_COLOR
         */
        "color": DividerColorType;
        /**
          * Orientation of the divider
          * @default DIVIDER_DEFAULT_ORIENTATION
         */
        "orientation": DividerOrientationType;
        /**
          * Size of the divider
          * @default DIVIDER_DEFAULT_SIZE
         */
        "size": DividerSizeType;
    }
    interface AthDropdown {
        /**
          * Text to announce the items found in search input
          * @default 'Hay [total] elementos en la lista'
         */
        "announceResultText": string;
        /**
          * Si dropdown esta deshabilitado
          * @default false
         */
        "disabled": boolean;
        /**
          * Nombre accesible para el dropdown
         */
        "dropdownAriaLabel": string;
        /**
          * Tipo feedback
          * @default dropdownFeedbackType.None
         */
        "feedback": dropdownFeedbackTypes;
        /**
          * Texto feedback
         */
        "feedbackText": string;
        /**
          * Texto de ayuda
         */
        "helperText": string;
        /**
          * If true, Do no show required mark for required input
          * @default false
         */
        "hideRequired": boolean;
        /**
          * Label dropdown
         */
        "label"?: string;
        /**
          * Si dropdown es multiseleccion
          * @default false
         */
        "multiselect": boolean;
        /**
          * The name of the combobox. Submitted with the form as part of a name/value pair
         */
        "name": string;
        /**
          * texto cuando multiselect es true, showChips es false y se selecciona una opcion
         */
        "nochipsText": string;
        /**
          * no result text
         */
        "noresultText": string;
        /**
          * Si dropdown esta abierto
          * @default false
         */
        "open": boolean;
        /**
          * Altura del overlay del dropdown
         */
        "overlayMaxHeight": string;
        /**
          * Placeholder
         */
        "placeholder": string;
        /**
          * Si dropdown es solo lectura
          * @default false
         */
        "readonly": boolean;
        /**
          * Si dropdown es obligatorio
          * @default false
         */
        "required": boolean;
        /**
          * Si dropdown tiene bloque de busqueda
          * @default false
         */
        "search": boolean;
        /**
          * Texto placeholder del bloque de busqueda
          * @default 'Buscar'
         */
        "searchAriaLabel": string;
        /**
          * Texto placeholder del bloque de busqueda
          * @default ''
         */
        "searchPlaceholder": string;
        /**
          * Mostrar chips
          * @default false
         */
        "showChips": boolean;
        /**
          * Tamaño dropdown
          * @default dropdownSize.Md
         */
        "size": dropdownSizes;
        /**
          * Texto del tooltip
         */
        "tooltipText": string;
        /**
          * Ancho del tooltip
          * @default 0
         */
        "tooltipWidth": number;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair
         */
        "value": string;
        /**
          * Ancho dropdown
         */
        "width": string;
    }
    interface AthDropdownOption {
        "activeDropdownOption": () => Promise<void>;
        /**
          * Si esta deshabilitado
          * @default false
         */
        "disabled": boolean;
        "filterFound": () => Promise<void>;
        "filterNotFound": (inputText: any) => Promise<void>;
        /**
          * icono para opcion
         */
        "icon": string;
        /**
          * name option
         */
        "name": string;
        "noActiveDropdownOption": () => Promise<void>;
        /**
          * Permite agrupaciones
         */
        "optionGroup": boolean;
        "selectOption": () => Promise<void>;
        /**
          * Si esta selecionado
          * @default false
         */
        "selected": boolean;
        /**
          * etiqueta accesible para la opcionseleccionada
          * @default 'seleccionada'
         */
        "selectedAriaLabel": string;
        "setSelected": (selected: boolean, opts?: { silent?: boolean; source?: "user" | "programmatic"; }) => Promise<void>;
        /**
          * texto del option
         */
        "text": string;
        "unselectOption": () => Promise<void>;
        "updateGroupOption": () => Promise<void>;
        "updateMultiselect": () => Promise<void>;
        /**
          * Valor del option
         */
        "value": string;
    }
    interface AthEmptyState {
        /**
          * Text to empty state description.
         */
        "description": string;
        /**
          * Indicates the heading level for the empty state.
          * @default 4
         */
        "headingLevel": number;
        /**
          * Indicates the heading size for the heading text.
          * @default HeadingSize.Sm
         */
        "headingSize": HeadingSizes;
        /**
          * Text to empty state heading
         */
        "headingText": string;
        /**
          * Indicates if the image will be hidden Does not apply when type is 'loading'
          * @default false
         */
        "hideImage": boolean;
        /**
          * Accesibility label for loading state (only when type is 'loading')
         */
        "loadingLabel": string;
        /**
          * Indicates the type of empty state
          * @default EmptyStateType.Empty
         */
        "type": EmptyStateTypes;
    }
    interface AthIcon {
        /**
          * The aria-label attribute of the icon
         */
        "ariaLabel": string | null;
        /**
          * The aria-labelledby attribute of the icon
         */
        "ariaLabelledby"?: string;
        /**
          * Color del icon
         */
        "color": IconColorTypes;
        /**
          * The icon name
         */
        "icon": string;
        /**
          * The size of the icon
          * @default IconSize.Medium
         */
        "size": IconSizeTypes;
    }
    interface AthInputCounter {
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled": boolean;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown.
          * @default InputCounterFeedbackTypes.None
         */
        "feedback": InputCounterFeedbackType;
        /**
          * The message for the feedback.
         */
        "feedbackText": string;
        /**
          * Message to help the user fill the input value.
         */
        "helperText": string;
        /**
          * If true, the controls are not visible.
          * @default false
         */
        "hideControls": boolean;
        /**
          * If true, the * asterisk will be hidden when the input is required.
          * @default false
         */
        "hideRequired": boolean;
        /**
          * The aria-label attribute of the input.
         */
        "inputAriaLabel": string;
        /**
          * Represents the caption of the input.
         */
        "label": string;
        /**
          * Represents the maximum number of the input.
         */
        "max": number;
        /**
          * Represents the minimum number of the input.
         */
        "min": number;
        /**
          * The name of the input. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder": string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly": boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required": boolean;
        /**
          * Specifies the size of the input.
          * @default InputCounterSizes.Medium
         */
        "size": InputCounterSize;
        /**
          * Specifies the interval between legal numbers in an <input> element.
          * @default 1
         */
        "step": number;
        /**
          * Specifies text for tooltip.
         */
        "tooltipText": string;
        /**
          * Specifies width for tooltip.
         */
        "tooltipWidth": number;
        /**
          * Specifies the unit for the input.
         */
        "unit": string;
        /**
          * Specifies the accesible unit for the input.
         */
        "unitAriaLabel": string;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value": string;
    }
    interface AthInputPassword {
        /**
          * Whether the input will be autocompleted.
         */
        "autocomplete": InputPasswordAutocomplete;
        /**
          * Whether the input is focused on page load.
         */
        "autofocus": boolean;
        /**
          * Shows a counter
         */
        "counter": boolean;
        /**
          * SThe label of the counter
          * @default '[length] de [max] caracteres. Quedan [rest]'
         */
        "counterLabel": string;
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled": boolean;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown
          * @default InputFeedbackTypes.None
         */
        "feedback": "error" | "success" | "warning" | "none";
        /**
          * The message for the feedback.
          * @default InputFeedbackTypes.Error
         */
        "feedbackText": "error" | "success" | "warning" | "none";
        /**
          * Message to help the user fills the input value
         */
        "helperText": string;
        /**
          * If true, the * asterisk will be show when required = true.
          * @default false
         */
        "hideRequired": boolean;
        /**
          * The aria-label attribute of the input
         */
        "inputAriaLabel": string;
        /**
          * Set tabindex
          * @default '0'
         */
        "inputTabindex": string;
        /**
          * Represents the caption of the input
         */
        "label": string;
        /**
          * The accesible text to button Hide Password
          * @default 'Ocultar password'
         */
        "labelHidePassword": string;
        /**
          * The accesible text to button Show Password
          * @default 'Ver password'
         */
        "labelShowPassword": string;
        /**
          * Specifies the maximum number of characters allowed in the input element
         */
        "maxlength": number;
        /**
          * The name of the input. Submitted with the form as part of a name/value pair
         */
        "name": string;
        /**
          * Specifies a regular expression that the input element's value is checked
         */
        "pattern": string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder": string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly": boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required": boolean;
        /**
          * Method to set the focus on the input element
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the input
          * @default InputSizes.Medium
         */
        "size": "lg" | "md" | "sm";
        /**
          * If true, submit the form when pressing Enter in the input field and the input is inside a form
          * @default false
         */
        "submitOnEnter": boolean;
        /**
          * The text to be shown in the tooltip
         */
        "tooltipText": string;
        /**
          * The max width to the text in the tooltip
         */
        "tooltipWidth": any;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value": string;
    }
    interface AthInputText {
        /**
          * Whether the input will be autocompleted.
         */
        "autocomplete": string;
        /**
          * Whether the input is focused on page load.
         */
        "autofocus": boolean;
        /**
          * The label and aria-label of the clear button
          * @default 'Borrar'
         */
        "clearButtonAriaLabel": string;
        /**
          * Shows a counter
         */
        "counter": boolean;
        /**
          * SThe label of the counter
          * @default '[length] de [max] caracteres. Quedan [rest]'
         */
        "counterLabel": string;
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled": boolean;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown
          * @default InputFeedbackTypes.None
         */
        "feedback": "error" | "none";
        /**
          * The feedback message.
         */
        "feedbackText": string;
        /**
          * Include a button to clear the value
          * @default false
         */
        "hasClear": boolean;
        /**
          * Message to help the user fills the input value
         */
        "helperText": string;
        /**
          * If true, the * asterisk will be hidden when required = true.
          * @default false
         */
        "hideRequired": boolean;
        /**
          * The icon name for the input's icon
         */
        "icon": string;
        /**
          * The icon position
          * @default InputIconPositions.Left
         */
        "iconPosition": "left" | "right";
        /**
          * The aria-label attribute of the input
         */
        "inputAriaLabel": string;
        /**
          * Set tabindex
          * @default '0'
         */
        "inputTabindex": string;
        /**
          * Represents the caption of the input
         */
        "label": string;
        /**
          * Specifies the maximum number of characters allowed in the input element
         */
        "maxlength": number;
        /**
          * The name of the input. Submitted with the form as part of a name/value pair
         */
        "name": string;
        /**
          * Specifies a regular expression that the input element's value is checked
         */
        "pattern": string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder": string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly": boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required": boolean;
        /**
          * Method to set the focus on the input element
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the input
          * @default InputSizes.Medium
         */
        "size": InputSize;
        /**
          * If true, submit the form when pressing Enter in the input field and the input is inside a form
          * @default false
         */
        "submitOnEnter": boolean;
        /**
          * The text to be shown in the tooltip
         */
        "tooltipText": string;
        /**
          * The max width to the text in the tooltip
         */
        "tooltipWidth": any;
        /**
          * The type of the input
          * @default InputTextTypes.Text
         */
        "type": "search" | "text" | "url" | "email" | "tel";
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value": string;
    }
    interface AthInputTextarea {
        /**
          * Whether the input will be autocompleted.
         */
        "autocomplete": string;
        /**
          * Whether the input is focused on page load.
         */
        "autofocus": boolean;
        /**
          * Shows a counter
         */
        "counter": boolean;
        /**
          * SThe label of the counter
          * @default '[length] de [max] caracteres. Quedan [rest]'
         */
        "counterLabel": string;
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled": boolean;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown
          * @default InputFeedbackTypes.None
         */
        "feedback": "error" | "none";
        /**
          * The feedback message.
         */
        "feedbackText": string;
        /**
          * Message to help the user fills the input value
         */
        "helperText": string;
        /**
          * If true, the * asterisk will be hidden when required = true.
          * @default false
         */
        "hideRequired": boolean;
        /**
          * The aria-label attribute of the input
         */
        "inputAriaLabel": string;
        /**
          * Set tabindex
          * @default '0'
         */
        "inputTabindex": string;
        /**
          * Represents the caption of the input
         */
        "label": string;
        /**
          * Specifies the maximum number of characters allowed in the input element
         */
        "maxlength": number;
        /**
          * The name of the input. Submitted with the form as part of a name/value pair
         */
        "name": string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder": string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly": boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required": boolean;
        /**
          * Number of visible rows.
         */
        "rows": number;
        /**
          * Method to set the focus on the input element
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the input
          * @default InputSizes.Medium
         */
        "size": InputSize1;
        /**
          * The text to be shown in the tooltip
         */
        "tooltipText": string;
        /**
          * The max width to the text in the tooltip
          * @default 0
         */
        "tooltipWidth": number;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value": string;
        /**
          * The max width to the text in the tooltip
         */
        "width": string;
    }
    interface AthLink {
        /**
          * aria-describedby para link
         */
        "ariaDescribedby": string;
        /**
          * aria-label para link
         */
        "ariaLabel": string | null;
        /**
          * aria-labelledby para link
         */
        "ariaLabelledby": string | null;
        /**
          * Indica si el link esta deshabilitado
         */
        "disabled": boolean;
        /**
          * Additional text to be appended to the aria-label to indicate that this is an external link
         */
        "externalLabel"?: string;
        /**
          * Indica el icono a usar
         */
        "icon": string;
        /**
          * Indica el aria-label para icono
         */
        "iconAriaLabel": string;
        /**
          * Url del destino
         */
        "linkHref": string;
        /**
          * Target para indicar donde se abrira
          * @default linkTarget.Blank
         */
        "linkTarget": linkTargets;
        /**
          * Tamaño link
          * @default linkSize.Md
         */
        "size": linkSizes;
        /**
          * Opcion del subrayado
          * @default true
         */
        "underline": boolean;
    }
    interface AthList {
        /**
          * List is clickable
          * @default false
         */
        "clickable": boolean;
        /**
          * List state disabled, only works if clickable is true
          * @default false
         */
        "disabled": boolean;
        /**
          * Define if the list contains dividers between items
         */
        "hasDivider": boolean;
        /**
          * Define the list orientation
          * @default ListOrientation.Vertical
         */
        "orientation": ListOrientationType;
        /**
          * List spacings size
          * @default ListSizes.Medium
         */
        "size": ListSizeType;
    }
    interface AthListItem {
        /**
          * The aria-label attribute of the clicable item
         */
        "athAriaLabel": string | null;
        /**
          * ListItem is clickable
          * @default false
         */
        "clickable": boolean;
        /**
          * List item description
         */
        "description": string;
        /**
          * List item state disabled, only works if clickable is true
          * @default false
         */
        "disabled": boolean;
        /**
          * Additional text to be appended to the aria-label to indicate that this is an external link
          * @default 'Se abre una ventana nueva'
         */
        "externalLabel"?: string;
        /**
          * List item divider. If user doesn't inform it, its informed from parent list
         */
        "hasDivider": boolean;
        /**
          * Heading level for the title
          * @default 4
         */
        "headingLevel": number;
        /**
          * List item title
         */
        "headingText": string;
        /**
          * URL when clickable is true
         */
        "href"?: string;
        /**
          * List item orientation. Its informed from parent list
          * @default ListOrientation.Vertical
         */
        "orientation": ListOrientationType;
        /**
          * Type of rel to url
         */
        "rel": string;
        /**
          * List item size. Its informed from parent list
          * @default ListSizes.Medium
         */
        "size": ListSizeType;
        /**
          * List item subtitle
         */
        "subtitle": string;
        /**
          * Type of target to url
          * @default ListLinkTarget.Self
         */
        "target": ListLinkTargetType;
        /**
          * List item tooltip
         */
        "tooltip": string;
        /**
          * Tooltip max-width
          * @default 240
         */
        "tooltipMaxWidth": number;
    }
    interface AthMenuButton {
        /**
          * The overlay's position relative to the origin
          * @default Alignment.Left
         */
        "alignment": Alignments;
        /**
          * The accesible label of the menu-button
         */
        "athAriaLabel": string;
        /**
          * Weather the button is focused by default
         */
        "autofocus": boolean;
        /**
          * The clear of the button (background and border color)
         */
        "clear": boolean;
        /**
          * The color variant of the button
          * @default ButtonColor.Primary
         */
        "color": ButtonColors;
        /**
          * The button is disabled
         */
        "disabled": boolean;
        /**
          * The code of the button's icon (used with iconPosition)
          * @default 'placeholder'
         */
        "icon": string;
        /**
          * Wheather the menu is open by default
         */
        "open": boolean;
        /**
          * Altura del overlay del menu
         */
        "overlayMaxHeight": string;
        /**
          * The size of the button
          * @default ButtonSize.Medium
         */
        "size": ButtonSizes;
    }
    interface AthMenuButtonItem {
        /**
          * Weather the button is disabled
         */
        "disabled": boolean;
        /**
          * The name of the grout the item belongs to
         */
        "groupName": string;
        /**
          * The icon of the menu-button-item
         */
        "icon": string;
        /**
          * @default -1
         */
        "itemTabIndex": number;
        /**
          * name option
         */
        "name": string;
        /**
          * The text of the menu-button-item
         */
        "text": string;
    }
    interface AthMenuHorizontal {
        /**
          * The accessible label for the menu
         */
        "athAriaLabel": string;
        /**
          * Whether the menu has a divider below
          * @default true
         */
        "hasDivider": boolean;
        /**
          * Items to generate using the imperative way
         */
        "items": MenuHorizontalItem[] | string;
    }
    interface AthMenuHorizontalItem {
        /**
          * The accessible text of the badge
         */
        "badgeLabel": string;
        /**
          * The maximum value inside the badge
         */
        "badgeMax": number;
        /**
          * The value of the badge
          * @default undefined
         */
        "badgeValue": number;
        /**
          * Whether the item is disabled or not
         */
        "disabled": boolean;
        /**
          * Additional text to be appended to the aria-label to indicate that this is an external link
          * @default '(Se abre en una nueva ventana)'
         */
        "externalLabel": string;
        /**
          * The URL of the item
         */
        "href": string;
        /**
          * The label of the item
         */
        "label": string;
        /**
          * Specifies the relationship of the linked URL
         */
        "rel": string;
        /**
          * Whether the item is selected or not
         */
        "selected": boolean;
        /**
          * The target of the link
          * @default TargetType.Self
         */
        "target": TargetTypes;
        "value": any;
    }
    interface AthMenuLateral {
        /**
          * (JSON) Object of items to generate
         */
        "items": MenuLateralItem[] | string;
    }
    interface AthMenuLateralItemAction {
        /**
          * The aria-label of the item
         */
        "ariaLabel": string | null;
        /**
          * The accesible label of the badge
         */
        "badgeLabel": string;
        /**
          * The maximum value inside the badge
         */
        "badgeMax": number;
        /**
          * The value inside the badge
         */
        "badgeValue": number;
        /**
          * Weather the button is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * The icon of the menu-button-item-action
         */
        "icon": string;
        /**
          * The name of the item, usefull in order to identify the selected item
         */
        "name": string;
        /**
          * Weather the button is selected
          * @default false
         */
        "selected": boolean;
        /**
          * Tooltip text
         */
        "tooltipText": string;
    }
    interface AthMenuLateralItemLink {
        /**
          * The aria-label of the item
         */
        "ariaLabel": string | null;
        /**
          * The accesible label of the badge
         */
        "badgeLabel": string;
        /**
          * The maximum value inside the badge
         */
        "badgeMax": number;
        /**
          * The value inside the badge
         */
        "badgeValue": number;
        /**
          * Weather the button is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * The text that indicates that the link open a new window
          * @default 'Se abre en una nueva ventana'
         */
        "externalLabel": string;
        /**
          * The URL of the link
         */
        "href": string;
        /**
          * The icon of the menu-button-item-link
         */
        "icon": string;
        /**
          * The name of the item, usefull in order to identify the selected item
         */
        "name": string;
        /**
          * The rel of the link
         */
        "rel": string;
        /**
          * Weather the button is selected
          * @default false
         */
        "selected": boolean;
        /**
          * The target of the link
          * @default TargetType.Self
         */
        "target": "self";
        /**
          * Tooltip text
         */
        "tooltipText": string;
    }
    interface AthMenuVertical {
        /**
          * Appearance of the menu
          * @default MenuVerticalAppearances.Primary
         */
        "appearance": MenuVerticalAppearance;
    }
    interface AthMenuVerticalItemAction {
        /**
          * Whether the item is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Icon of the item
         */
        "icon": string;
        /**
          * Whether an item with children is open by default.
          * @default false
         */
        "open": boolean;
        /**
          * Whether the item is selected
          * @default false
         */
        "selected": boolean;
        /**
          * Title of the item
         */
        "text": string;
        /**
          * Value of the item, in order to identify it.
         */
        "value": string;
    }
    interface AthMenuVerticalItemLink {
        /**
          * Whether the link is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * The text that indicates that the link open a new window
          * @default 'Se abre en una nueva ventana'
         */
        "externalLabel": string;
        /**
          * URL of the link
         */
        "href": string;
        /**
          * Icon of the item
         */
        "icon": string;
        /**
          * rel of the link
         */
        "rel": string;
        /**
          * Whether the link is selected
          * @default false
         */
        "selected": boolean;
        /**
          * target of the link: blank | self
          * @default menuItemLinkTargets.Blank
         */
        "target": menuItemLinkTarget;
        /**
          * Title of the link
         */
        "text": string;
        /**
          * Value of the item, in order to identify it.
         */
        "value": string;
    }
    interface AthModal {
        /**
          * Indicates the illustration used when the prop isAlert is set to true
          * @default ModalAppearance.Error
         */
        "appearance": ModalAppearanceType;
        /**
          * Indicates whether the modal should automatically focus the first interactive element
          * @default true
         */
        "autofocus": boolean;
        /**
          * Indicates whether the modal should close when clicking outside
          * @default false
         */
        "clickOutsideClose": boolean;
        /**
          * Accessible text for the close (X) button
         */
        "closeAriaLabel": string;
        /**
          * Method to close the modal
         */
        "closeModal": () => Promise<void>;
        /**
          * Indicates whether the modal will occupy the full screen
          * @default false
         */
        "fullScreen": boolean;
        /**
          * Indicates whether the modal has a close (X) button
          * @default true
         */
        "hasClose": boolean;
        /**
          * Indicates whether there is a divider between the header and the slots
          * @default false
         */
        "hasDivider": boolean;
        /**
          * Indicates the heading level of the title
          * @default 2
         */
        "headingLevel": number;
        /**
          * Indicates the title text
         */
        "headingText": string;
        /**
          * Indicates whether the modal has role "Alert", and interrupts the screen reader flow
          * @default false
         */
        "isAlert": boolean;
        /**
          * Indicates the maximum height of the modal
         */
        "maxHeight": string;
        /**
          * Indicates the maximum width of the modal
         */
        "maxWidth": string;
        /**
          * Indicates whether the modal is displayed by default
          * @default false
         */
        "open": boolean;
        /**
          * Method to open the modal
         */
        "openModal": () => Promise<void>;
        /**
          * Differentiates the modal size between sm and md
          * @default ModalSize.Medium
         */
        "size": ModalSizeType;
        /**
          * Indicates the subtitle text
         */
        "subtitleText": string;
    }
    interface AthPagination {
        /**
          * ARIA label for the pagination component.
          * @default 'Paginación de resultados'
         */
        "athAriaLabel": string;
        /**
          * Current active page number in the pagination.
          * @default 1
         */
        "currentPage": number;
        /**
          * Determines whether the Pagination is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Defines the number of items displayed per page in the pagination.
         */
        "itemsPerPage": number;
        /**
          * Defines the selectable options for the number of items of the dropdown.
          * @default '[5, 10, 15]'
         */
        "itemsSelector": string;
        /**
          * Hide the buttons to navigate to the first and last pages.
          * @default false
         */
        "noEndButtons": boolean;
        /**
          * Determines whether the item count message is displayed in the pagination.
          * @default false
         */
        "noItemsCount": boolean;
        /**
          * Determines whether a dropdown is shown to select the number of items per page.
          * @default false
         */
        "noItemsSelector": boolean;
        /**
          * Hide the buttons to jump to the previous or next pages.
          * @default false
         */
        "noJumpButtons": boolean;
        /**
          * Total number of items over all pages.
         */
        "totalItems": number;
    }
    interface AthPanel {
        /**
          * Si el panel puede recibir el foco o no
          * @default false
         */
        "focusable": boolean;
        /**
          * Etiqueta accesible para el panel
         */
        "label": string;
    }
    interface AthPictogram {
        /**
          * The aria-label attribute of the pictogram
         */
        "ariaLabel": string | null;
        /**
          * The aria-labelledby attribute of the pictogram
         */
        "ariaLabelledby"?: string;
        /**
          * The pictogram name
         */
        "name": string;
        /**
          * The size of the pictogram
          * @default PictogramSizeType.Medium
         */
        "size": PictogramSizeTypes;
    }
    interface AthProgressBar {
        /**
          * Aria Label
         */
        "athAriaLabel": string;
        /**
          * Infinite determines if the progress bar is a loop or not
          * @default false
         */
        "infinite": boolean;
        /**
          * Change label alignment
          * @default ProgressBarLabelAlignment.Stack
         */
        "labelAlignment": ProgressBarLabelAlignmentType;
        /**
          * Text of the label left
         */
        "labelLeft": string;
        /**
          * Text of the label right
         */
        "labelRight": string;
        /**
          * Number max of progress bar
          * @default 100
         */
        "max": number;
        /**
          * Number min of progress bar
          * @default 0
         */
        "min": number;
        /**
          * Value of the progress bar
         */
        "value": number;
        /**
          * Value text of the progress bar
         */
        "valueText": string;
    }
    interface AthRadioButton {
        /**
          * Accessible text (aria-label)
         */
        "ariaLabel": string | null;
        /**
          * Indicates if it is checked by default
          * @default false
         */
        "checked": boolean;
        /**
          * Indicates if it is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Label text
         */
        "label": string;
        /**
          * Indicates the name of the radioButton
         */
        "name": string;
        /**
          * Indicates if it is read-only
          * @default false
         */
        "readonly": boolean;
        "setFocus": () => Promise<void>;
        "setTabindex": (tabIndex: any) => Promise<void>;
        "unCheck": () => Promise<void>;
        /**
          * Indicates the value of the radioButton
         */
        "value": string;
    }
    interface AthRadioButtonGroup {
        /**
          * Accessible name for the group
         */
        "ariaLabel": string | null;
        /**
          * Indicates whether the group is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Indicates the Feedback type
          * @default FeedbackTypes.None
         */
        "feedback": FeedbackType;
        /**
          * Feedback text to be displayed
         */
        "feedbackText": string;
        /**
          * Helper text to be displayed
         */
        "helperText": string;
        /**
          * Label text
         */
        "label": string;
        /**
          * Name attribute to apply to the whole group
         */
        "name": string;
        /**
          * Indicates the orientation of the group
          * @default OrientationTypes.Vertical
         */
        "orientation": OrientationType;
        /**
          * Indicates whether the group is read-only
          * @default false
         */
        "readonly": boolean;
        /**
          * Screen-reader-only text indicating the group is required
         */
        "requiredAriaLabel": string;
        /**
          * Indicates whether to show the asterisk
          * @default false
         */
        "showRequired": boolean;
        /**
          * Tooltip text
         */
        "tooltipText": string;
        /**
          * Tooltip width
          * @default 0
         */
        "tooltipWidth": number;
        /**
          * Set the value to select the checked ath-radio-button
         */
        "value": string;
    }
    interface AthSectionTitle {
        /**
          * 'The 'Section title' can become a button that shows or hides the content of the 'Collapse' component.
         */
        "collapsable": boolean;
        /**
          * Identifier of the 'Collapse' component whose visibility is controlled by this 'Section title'.
         */
        "collapseTarget": string;
        /**
          * Color assigned to the decorative element and the 'overline' text.
          * @default SectionTitleColor.Primary
         */
        "color": SectionTitleColorType;
        /**
          * Heading level assigned to the title. If 0, a <p> tag is assigned. Values between 1 and 6 correspond to <h1> ... <h6>.
          * @default 4
         */
        "headingLevel": number;
        /**
          * Heading level assigned to the overline. If 0, a <p> tag is assigned. Values between 1 and 6 correspond to <h1> ... <h6>.
          * @default 0
         */
        "headingOverline": number;
        /**
          * Indicates the heading size for the heading text.
          * @default HeadingSize.Sm
         */
        "headingSize": HeadingSizes1;
        /**
          * Section title.
         */
        "headingText": string;
        /**
          * The code of the Section Title's icon (used with type Icon)
         */
        "icon": string;
        /**
          * Text above the title, usually used to categorize the content.
         */
        "overline": string;
        /**
          * The code of the Section Title's pictogram (used with type Pictogram)
         */
        "pictogram": string;
        /**
          * Tooltip text to be included.
          * @default ''
         */
        "tooltip": string;
        /**
          * Tooltip aria-label.
          * @default 'Más información'
         */
        "tooltipLabel": string;
        /**
          * Option assigned to the decorative element.
          * @default SectionTitleOption.Default
         */
        "type": SectionTitleOptionType;
    }
    interface AthSegmentedControl {
        /**
          * Text to show when the label of segmented control its not visible
         */
        "ariaLabel": string | null;
        /**
          * Color of the segmented control
          * @default SegmentedControlColors.Primary
         */
        "color": SegmentedControlColor;
        /**
          * The segmented control is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Type of feedback to show
          * @default SegmentedControlFeedbackType.None
         */
        "feedback": SegmentedControlFeedback;
        /**
          * Feedback text
         */
        "feedbackText": string;
        /**
          * Helper text for the segmented control
         */
        "helperText": string;
        /**
          * Show if is required in the label
          * @default false
         */
        "hideRequired": boolean;
        /**
          * Label text for the segmented control
         */
        "label": string;
        /**
          * The name of the segmented control to use with forms
         */
        "name": string;
        /**
          * Show if is required
          * @default false
         */
        "required": boolean;
        /**
          * Show if is required in the label
         */
        "requiredAriaLabel": any;
        /**
          * Size of the segmented control
          * @default SegmentedControlSizes.Medium
         */
        "size": SegmentedControlSize;
        /**
          * Show the tooltip text
         */
        "tooltipText": string;
        /**
          * Show the width of the tooltip
          * @default 0
         */
        "tooltipWidth": number;
        /**
          * Types of the segmented control
          * @default SegmentedControlTypes.Select
         */
        "type": SegmentedControlType;
        /**
          * Set the value to select the checked ath-radio-button
         */
        "value": string;
    }
    interface AthSegmentedControlItem {
        /**
          * Size of the segmented control item
          * @default SegmentedControlColors.Primary
         */
        "color": SegmentedControlColor;
        /**
          * The segmented control is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * The code of the button's icon (used with iconPosition)
         */
        "icon": string;
        /**
          * Icon position of the segmented control item
          * @default SegmentedControlItemIconPositions.None
         */
        "iconPosition": SegmentedControlItemIconPosition;
        /**
          * The segmented control item is selected
          * @default false
         */
        "selected": boolean;
        "setFocus": () => Promise<void>;
        "setTabindex": (index: number) => Promise<void>;
        /**
          * Size of the segmented control item
          * @default SegmentedControlSizes.Medium
         */
        "size": SegmentedControlSize;
        /**
          * The type of the control
          * @default SegmentedControlTypes.Select
         */
        "type": SegmentedControlType;
        "unSelectItem": () => Promise<void>;
        /**
          * The value for a Segmented Control with type select (role radio)
         */
        "value": string;
    }
    interface AthSlider {
        /**
          * The ath-input-counter width.
          * @default 'auto'
         */
        "counterWidth": string;
        /**
          * Detail text at the left of the slider
         */
        "detailFirst": string;
        /**
          * Detail text at the right of the slider
         */
        "detailLast": string;
        /**
          * If true, the user cannot interact with the slider and the inputs.
          * @default false
         */
        "disabled": boolean;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown.
          * @default SliderFeedbackTypes.None
         */
        "feedback": SliderFeedbackType;
        /**
          * Feedback error for input counter if is from, to, both or none.
          * @default SliderFeedbackErrorCounterTypes.None
         */
        "feedbackCounter": SliderFeedbackErrorCounterType;
        /**
          * The message for the feedback.
         */
        "feedbackText": string;
        /**
          * The aria-label attribute of the first input-counter.
         */
        "fromAriaLabel": string;
        /**
          * The aria-label attribute of the slider.
         */
        "groupAriaLabel": string;
        /**
          * Message to help the user fill the input value.
         */
        "helperText": string;
        /**
          * Label slider
         */
        "labelGroup": string;
        /**
          * Represents the maximum number of the input & slider.
          * @default 100
         */
        "max": number;
        /**
          * Represents the minimum number of the input & slider.
          * @default 0
         */
        "min": number;
        /**
          * The name of the slider. Submitted with the form as part of a name/value pair
         */
        "name": string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly": boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required": boolean;
        /**
          * If true, the * asterisk will be show when required = true.
          * @default true
         */
        "showRequired": boolean;
        /**
          * Specifies the interval between legal numbers in an <input> element & slider.
          * @default 1
         */
        "step": number;
        /**
          * If true show step marks.
          * @default false
         */
        "stepped": boolean;
        /**
          * The aria-label attribute of the second input-counter.
         */
        "toAriaLabel": string;
        /**
          * Specifies text for tooltip.
         */
        "tooltipText": string;
        /**
          * The type of slider. if range shows two handles to select between two numbers.
          * @default SliderTypes.Default
         */
        "type": SliderType;
        /**
          * Specifies the unit for the input.
         */
        "unit": string;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
          * @default this.min.toString()
         */
        "value": string;
        /**
          * The aria-valuetext attribute for slider.
         */
        "valueText": string;
        /**
          * Specifies the width for slider.
         */
        "width": string;
    }
    interface AthStep {
        /**
          * Defines the action text
         */
        "actionText": string;
        /**
          * Indicates the alignment of the step
         */
        "alignment": StepAlignmentType;
        /**
          * Defines the accessible message announced when the step changes to selected.Only applied on non-interactive steps
         */
        "ariaLiveMessage": string;
        /**
          * Defines the accessible text for the step
         */
        "athAriaLabel": string;
        /**
          * Identifies the step by its position in the list
         */
        "athId": number;
        /**
          * Indicates if the step is a button or a link
          * @default StepRole.Button
         */
        "athRole": StepRoleType;
        /**
          * Indicates if the step is interactive
         */
        "clickable": boolean;
        /**
          * Defines the accessible text for the chevron when its function is to collapse
         */
        "collapseLabel": string;
        /**
          * Defines the accessible text for the completed state
         */
        "completedLabel": string;
        /**
          * Indicates if the step is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Specifies the accessible text for the error indicator
         */
        "errorLabel": string;
        /**
          * Indicates the custom accessible text for the chevron to expand
         */
        "expandLabel": string;
        /**
          * Indicates if the step contains an error
          * @default StepFeedback.None
         */
        "feedback": StepFeedbackType;
        /**
          * Defines the title of the step
         */
        "headingText": string;
        /**
          * Indicates if the step is collapsable
          * @default false
         */
        "isCollapsable": boolean;
        /**
          * Indicates if the step is completed
          * @default false
         */
        "isComplete": boolean;
        /**
          * Indicates if the slot is expanded
          * @default false
         */
        "isExpanded": boolean;
        /**
          * Indicates the number of the step
         */
        "number": number;
        /**
          * Indicates that the step is read-only
          * @default false
         */
        "readonly": boolean;
        /**
          * Indicates that the step is in progress
         */
        "selected": boolean;
        /**
          * Sets the size of the step
         */
        "size": StepSizeType;
        /**
          * Indicates the total number of steps in the stepper
         */
        "total": number;
    }
    interface AthStepper {
        /**
          * Defines the message for screen readers when changing the step. Only applied on non-interactive steps
          * @default 'Paso actual [number]'
         */
        "ariaLiveMessage": string;
        /**
          * Defines the accessible text for the step
         */
        "athAriaLabel": string;
        /**
          * Indicates the role of the step
          * @default StepRole.Button
         */
        "athRole": StepRoleType;
        /**
          * Indicates if the steps are interactive
          * @default true
         */
        "clickable": boolean;
        /**
          * Indicates the custom accessible text for the chevron to collapse
          * @default 'Colapsar paso [number]'
         */
        "collapseLabel": string;
        /**
          * Specifies the accessible text for the CHECK indicator of completion, which will be injected into the steps
          * @default 'Completado'
         */
        "completedLabel": string;
        /**
          * Specifies the accessible text for the error indicator in steps
          * @default 'Error'
         */
        "errorLabel": string;
        /**
          * Indicates the custom accessible text for the chevron to expand
          * @default 'Expandir paso [number]'
         */
        "expandLabel": string;
        /**
          * Indicates the icon to use in the title
         */
        "headingIcon": string;
        /**
          * Indicates the title of the stepper
         */
        "headingText": string;
        /**
          * Indicates the orientation of the stepper
          * @default StepperOrientation.Horizontal
         */
        "orientation": StepperOrientationType;
        /**
          * Indicates if the all the steps are read-only
          * @default false
         */
        "readonly": boolean;
        /**
          * Indicates the size of the steps
          * @default StepperSize.Medium
         */
        "size": StepperSizeType;
        /**
          * Indicates the number of the first step
          * @default 1
         */
        "startFrom": number;
    }
    interface AthSwitch {
        /**
          * Determines if the switch is disabled and cannot be interacted with
          * @default false
         */
        "disabled": boolean;
        /**
          * Name to identify the switch
         */
        "name": string;
        /**
          * Makes the switch read-only, preventing user interaction while still being focusable
          * @default false
         */
        "readonly": boolean;
        /**
          * Controls the selected/unselected state of the switch
          * @default false
         */
        "selected": boolean;
        "setFocus": () => Promise<void>;
    }
    interface AthTab {
        /**
          * Si la tab está deshabilitada o no
         */
        "disabled": boolean;
        /**
          * Código del icono en caso de que la tab deba llevar icono
         */
        "icon": string;
        /**
          * Etiqueta accesible del icono
         */
        "iconAriaLabel": string;
        /**
          * Etiqueta accesible de la tab
         */
        "label": string;
        /**
          * Ruta de navegación de la tab
         */
        "navigationData": string;
        /**
          * Si la tab está seleccionada por defecto
         */
        "selected": boolean;
    }
    interface AthTable {
        /**
          * Enable clickable rows with action column
          * @default false
         */
        "clickable": boolean;
        /**
          * Table color
          * @default TableColor.Primary
         */
        "color": TableColorType;
        /**
          * Fix the first or last column
         */
        "frozen": TableFrozenType;
        /**
          * Hides select all checkbox when selectable is multiple
          * @default false
         */
        "noSelectAll": boolean;
        /**
          * Refresh the table. Useful when dynamically changing content
         */
        "refresh": () => Promise<void>;
        /**
          * Row selection mode
          * @default TableSelectable.None
         */
        "selectable": TableSelectableType;
        /**
          * Row height
          * @default TableSize.Small
         */
        "size": TableSizeType;
        /**
          * Enable zebra striping
          * @default TableStriping.None
         */
        "striped": TableStripingType;
    }
    interface AthTableBody {
    }
    interface AthTableHeader {
        /**
          * Enable clickable rows with action column
          * @default false
         */
        "clickable": boolean;
        /**
          * Header color
          * @default TableColor.Primary
         */
        "color": TableColorType;
        /**
          * If the row has a fixed column, specify if it's the first or last column
          * @default TableFrozen.None
         */
        "frozen": TableFrozenType;
        /**
          * Hides select all checkbox when selectable is multiple
          * @default false
         */
        "noSelectAll": boolean;
        /**
          * Current state of the select all checkbox (false | true | indeterminate)
          * @default CheckboxValue.False
         */
        "selectAllState": CheckboxValues;
        /**
          * Selection mode (none | single | multiple)
          * @default TableSelectable.None
         */
        "selectable": TableSelectableType;
        /**
          * Number of currently selected rows (used for determining indeterminate state)
          * @default 0
         */
        "selectedRows": number;
        /**
          * Header size
         */
        "size": TableSizeType;
        /**
          * Total number of selectable rows (used for determining indeterminate state)
          * @default 0
         */
        "totalRows": number;
    }
    interface AthTableHeaderItem {
        /**
          * Column alignment
         */
        "alignment": TableAlignmentType;
        /**
          * Column width (px, %, auto)
          * @default 'auto'
         */
        "cellWidth": string;
        /**
          * Item color
          * @default TableColor.Primary
         */
        "color": TableColorType;
        /**
          * If this column is fixed
         */
        "frozen": TableFrozenType;
        /**
          * If this column contains interactive elements (menus, buttons, links, etc.). This property will be passed down to all row items in the same column.
          * @default false
         */
        "hasInteractivity": boolean;
        /**
          * Item size
         */
        "size": TableSizeType;
    }
    interface AthTableRow {
        /**
          * Enable clickable functionality
          * @default false
         */
        "clickable": boolean;
        /**
          * Aria label of row click button
          * @default 'Navegar'
         */
        "clickableAriaLabel": string;
        /**
          * Row color
          * @default TableColor.Primary
         */
        "color": TableColorType;
        /**
          * Controls the expanded state for rows that have children
          * @default false
         */
        "expanded": boolean;
        /**
          * If the row has a fixed column, specify if it's the first or last column
          * @default TableFrozen.None
         */
        "frozen": TableFrozenType;
        /**
          * Whether this row has children
          * @default false
         */
        "hasChildren": boolean;
        /**
          * Indicates that this is the last visual row (no border). Internal use by ath-table
          * @default false
         */
        "last": boolean;
        /**
          * Optional parent row id if this row is a child
         */
        "parentId"?: string;
        /**
          * Reserve space for clickable column. Internal use by ath-table
          * @default false
         */
        "reserveClickable": boolean;
        /**
          * Reserve space for expander column even if this row has no children. Internal use by ath-table
          * @default false
         */
        "reserveExpander": boolean;
        /**
          * Unique id for this row
         */
        "rowId"?: string;
        /**
          * Selection mode (none | single | multiple)
          * @default TableSelectable.None
         */
        "selectable": TableSelectableType;
        /**
          * Current selection state
          * @default false
         */
        "selected": boolean;
        /**
          * Group name for radios in single mode
         */
        "selectionGroupName": string;
        /**
          * Row size
         */
        "size": TableSizeType;
        /**
          * Apply zebra striping
          * @default TableStriping.None
         */
        "striped": TableStripingType;
        /**
          * Optional row value to be included in selection events
         */
        "value": any;
    }
    interface AthTableRowItem {
        /**
          * Cell alignment
         */
        "alignment": TableAlignmentType;
        /**
          * Column width (px, %, auto)
          * @default 'auto'
         */
        "cellWidth": string;
        /**
          * Background color
          * @default TableColor.Primary
         */
        "color": TableColorType;
        /**
          * Current expanded state (used when expander = true)
          * @default false
         */
        "expanded": boolean;
        /**
          * Marks this cell as an expander control (collapse/expand). Internal use by ath-table-row.
          * @default false
         */
        "expander": boolean;
        /**
          * Aria-controls value for the expander button (ID of the collapsable content)
         */
        "expanderAriaControls": string;
        /**
          * If this cell is fixed, created a first or last column fixed
          * @default TableFrozen.None
         */
        "frozen": TableFrozenType;
        /**
          * If this cell contains interactive elements (menus, buttons, links, etc.). When true, row click events will be prevented to avoid conflicts with cell interactions.
          * @default false
         */
        "hasInteractivity": boolean;
        /**
          * Marks this cell as the first data cell of a child row (for indentation)
          * @default false
         */
        "isChild": boolean;
        /**
          * If this cell is header of the row
          * @default false
         */
        "isHeader": boolean;
        /**
          * If true, no shadow will be applied to the frozen cell
          * @default false
         */
        "noFrozenShadow": boolean;
        /**
          * Table size
         */
        "size": TableSizeType;
        /**
          * Striped background
          * @default false
         */
        "striped": boolean;
    }
    interface AthTabs {
        /**
          * Lista de tabs a generar
         */
        "items": TabItem[] | string;
        /**
          * Etiqueta accesible para la lista de tabs
         */
        "listAriaLabel": string;
        /**
          * Tipo de Tabs
          * @default TabsTypes.Underline
         */
        "type": TabsType;
    }
    interface AthTag {
        /**
          * Color del tag acompañando al propósito del mensaje
          * @default TAG_DEFAULT_COLOR
         */
        "color": TagColorTypes;
        /**
          * Texto que se visualiza dentro del tag
         */
        "headingText": string;
        /**
          * Icono
         */
        "icon": string;
        /**
          * Tamaño del tag
          * @default TAG_DEFAULT_SIZE
         */
        "size": TagSizes;
    }
    interface AthText {
        /**
          * Define color del texto: default, inverse, primary, accent, subtle
          * @default TextColor.Default
         */
        "color": AthTextColor;
        /**
          * Número de columnas y espaciado que se muestran
         */
        "columns"?: AthTextColumns | string;
        /**
          * Texto dentro del componente
         */
        "content": string;
        /**
          * Define semánticamente la jerarquías del texto: p, h1, h2, h3...
          * @default defaultAthTextModel.hierarchy
         */
        "hierarchy": 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
        /**
          * Número de líneas máximo a mostrar
         */
        "lines"?: number;
        /**
          * Mostrar tooltip con el contenido completo cuando el texto aparece truncado
         */
        "withTooltip"?: boolean;
    }
    interface AthTooltip {
        /**
          * The variant of the tooltip
          * @default TooltipColor.Primary
         */
        "color": TooltipColors;
        /**
          * Whether the tooltip has an arrow
          * @default true
         */
        "hasArrow": boolean;
        /**
          * The text in the tooltip
          * @default ''
         */
        "headingText": string;
        /**
          * Whether the tooltip has a maximum width, and if so, the maximum width
          * @default 240
         */
        "maxWidth": number;
        /**
          * The position of the tooltip
          * @default TooltipPosition.Right
         */
        "position": TooltipPositions;
        /**
          * The action that will show the tooltip
          * @default TooltipTrigger.Hover
         */
        "trigger": TooltipTriggers;
    }
    interface AthTooltipTrigger {
        /**
          * The aria-label attribute of the icon
          * @default 'Más información'
         */
        "ariaLabel": string | null;
        /**
          * The icon name
          * @default Icons.Info
         */
        "icon": string;
        /**
          * The size of the icon
          * @default 'md'
         */
        "size": IconSizeTypes;
    }
    interface AthUserDetail {
        /**
          * The aria-label attribute of the button-link.
         */
        "buttonAriaLabel": string;
        /**
          * If true, the user can click the button-link.
          * @default false
         */
        "clickable": boolean;
        /**
          * User Description.
         */
        "description": string;
        /**
          * User initials.
         */
        "initials": string;
        /**
          * Avatar SRC image.
         */
        "srcImage": string;
        /**
          * Type of avatar.
          * @default undefined
         */
        "type": UserDetailType;
        /**
          * User Name.
         */
        "userName": string;
    }
    interface AthUserMenu {
        /**
          * Initials to display in the avatar.
         */
        "initials": string;
        /**
          * Indica si user-menu esta abierto
          * @default false
         */
        "open": boolean;
        /**
          * Define la src para imagen avatar
         */
        "srcImage": string;
        /**
          * Define el tipo de avatar
          * @default undefined
         */
        "type": UserMenuType;
        /**
          * Define el nombre del usuario
         */
        "userName": string;
    }
}
export interface AthAccordionItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthAccordionItemElement;
}
export interface AthButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthButtonElement;
}
export interface AthButtonExpandableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthButtonExpandableElement;
}
export interface AthButtonLinkCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthButtonLinkElement;
}
export interface AthCalendarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthCalendarElement;
}
export interface AthCardCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthCardElement;
}
export interface AthCardSelectableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthCardSelectableElement;
}
export interface AthCardSelectableGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthCardSelectableGroupElement;
}
export interface AthCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthCheckboxElement;
}
export interface AthCheckboxGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthCheckboxGroupElement;
}
export interface AthChipChoiceCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthChipChoiceElement;
}
export interface AthChipChoiceGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthChipChoiceGroupElement;
}
export interface AthChipDismissCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthChipDismissElement;
}
export interface AthCollapseCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthCollapseElement;
}
export interface AthDatepickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthDatepickerElement;
}
export interface AthDatepickerRangeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthDatepickerRangeElement;
}
export interface AthDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthDropdownElement;
}
export interface AthDropdownOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthDropdownOptionElement;
}
export interface AthInputCounterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthInputCounterElement;
}
export interface AthInputPasswordCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthInputPasswordElement;
}
export interface AthInputTextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthInputTextElement;
}
export interface AthInputTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthInputTextareaElement;
}
export interface AthLinkCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthLinkElement;
}
export interface AthListItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthListItemElement;
}
export interface AthMenuButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthMenuButtonElement;
}
export interface AthMenuButtonItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthMenuButtonItemElement;
}
export interface AthMenuHorizontalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthMenuHorizontalElement;
}
export interface AthMenuLateralCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthMenuLateralElement;
}
export interface AthMenuVerticalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthMenuVerticalElement;
}
export interface AthModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthModalElement;
}
export interface AthPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthPaginationElement;
}
export interface AthRadioButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthRadioButtonElement;
}
export interface AthRadioButtonGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthRadioButtonGroupElement;
}
export interface AthSectionTitleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthSectionTitleElement;
}
export interface AthSegmentedControlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthSegmentedControlElement;
}
export interface AthSegmentedControlItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthSegmentedControlItemElement;
}
export interface AthSliderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthSliderElement;
}
export interface AthStepCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthStepElement;
}
export interface AthStepperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthStepperElement;
}
export interface AthSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthSwitchElement;
}
export interface AthTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthTableElement;
}
export interface AthTableHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthTableHeaderElement;
}
export interface AthTableRowCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthTableRowElement;
}
export interface AthTooltipTriggerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthTooltipTriggerElement;
}
export interface AthUserDetailCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthUserDetailElement;
}
export interface AthUserMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAthUserMenuElement;
}
declare global {
    interface HTMLAthAccordionElement extends Components.AthAccordion, HTMLStencilElement {
    }
    var HTMLAthAccordionElement: {
        prototype: HTMLAthAccordionElement;
        new (): HTMLAthAccordionElement;
    };
    interface HTMLAthAccordionItemElementEventMap {
        "opened": void;
    }
    interface HTMLAthAccordionItemElement extends Components.AthAccordionItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthAccordionItemElementEventMap>(type: K, listener: (this: HTMLAthAccordionItemElement, ev: AthAccordionItemCustomEvent<HTMLAthAccordionItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthAccordionItemElementEventMap>(type: K, listener: (this: HTMLAthAccordionItemElement, ev: AthAccordionItemCustomEvent<HTMLAthAccordionItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthAccordionItemElement: {
        prototype: HTMLAthAccordionItemElement;
        new (): HTMLAthAccordionItemElement;
    };
    interface HTMLAthActionBarElement extends Components.AthActionBar, HTMLStencilElement {
    }
    var HTMLAthActionBarElement: {
        prototype: HTMLAthActionBarElement;
        new (): HTMLAthActionBarElement;
    };
    interface HTMLAthAlertElement extends Components.AthAlert, HTMLStencilElement {
    }
    var HTMLAthAlertElement: {
        prototype: HTMLAthAlertElement;
        new (): HTMLAthAlertElement;
    };
    interface HTMLAthAvatarElement extends Components.AthAvatar, HTMLStencilElement {
    }
    var HTMLAthAvatarElement: {
        prototype: HTMLAthAvatarElement;
        new (): HTMLAthAvatarElement;
    };
    interface HTMLAthBadgeElement extends Components.AthBadge, HTMLStencilElement {
    }
    var HTMLAthBadgeElement: {
        prototype: HTMLAthBadgeElement;
        new (): HTMLAthBadgeElement;
    };
    interface HTMLAthBreadcrumbElement extends Components.AthBreadcrumb, HTMLStencilElement {
    }
    var HTMLAthBreadcrumbElement: {
        prototype: HTMLAthBreadcrumbElement;
        new (): HTMLAthBreadcrumbElement;
    };
    interface HTMLAthButtonElementEventMap {
        "athClick": void;
        "athFocus": void;
        "athBlur": void;
    }
    interface HTMLAthButtonElement extends Components.AthButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthButtonElementEventMap>(type: K, listener: (this: HTMLAthButtonElement, ev: AthButtonCustomEvent<HTMLAthButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthButtonElementEventMap>(type: K, listener: (this: HTMLAthButtonElement, ev: AthButtonCustomEvent<HTMLAthButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthButtonElement: {
        prototype: HTMLAthButtonElement;
        new (): HTMLAthButtonElement;
    };
    interface HTMLAthButtonExpandableElementEventMap {
        "athToggleCollapse": string;
    }
    interface HTMLAthButtonExpandableElement extends Components.AthButtonExpandable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthButtonExpandableElementEventMap>(type: K, listener: (this: HTMLAthButtonExpandableElement, ev: AthButtonExpandableCustomEvent<HTMLAthButtonExpandableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthButtonExpandableElementEventMap>(type: K, listener: (this: HTMLAthButtonExpandableElement, ev: AthButtonExpandableCustomEvent<HTMLAthButtonExpandableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthButtonExpandableElement: {
        prototype: HTMLAthButtonExpandableElement;
        new (): HTMLAthButtonExpandableElement;
    };
    interface HTMLAthButtonLinkElementEventMap {
        "athClick": void;
        "athFocus": void;
        "athBlur": void;
    }
    interface HTMLAthButtonLinkElement extends Components.AthButtonLink, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthButtonLinkElementEventMap>(type: K, listener: (this: HTMLAthButtonLinkElement, ev: AthButtonLinkCustomEvent<HTMLAthButtonLinkElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthButtonLinkElementEventMap>(type: K, listener: (this: HTMLAthButtonLinkElement, ev: AthButtonLinkCustomEvent<HTMLAthButtonLinkElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthButtonLinkElement: {
        prototype: HTMLAthButtonLinkElement;
        new (): HTMLAthButtonLinkElement;
    };
    interface HTMLAthCalendarElementEventMap {
        "athChange": string;
    }
    interface HTMLAthCalendarElement extends Components.AthCalendar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthCalendarElementEventMap>(type: K, listener: (this: HTMLAthCalendarElement, ev: AthCalendarCustomEvent<HTMLAthCalendarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthCalendarElementEventMap>(type: K, listener: (this: HTMLAthCalendarElement, ev: AthCalendarCustomEvent<HTMLAthCalendarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthCalendarElement: {
        prototype: HTMLAthCalendarElement;
        new (): HTMLAthCalendarElement;
    };
    interface HTMLAthCardElementEventMap {
        "athClick": void;
        "athFocus": void;
        "athBlur": void;
    }
    interface HTMLAthCardElement extends Components.AthCard, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthCardElementEventMap>(type: K, listener: (this: HTMLAthCardElement, ev: AthCardCustomEvent<HTMLAthCardElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthCardElementEventMap>(type: K, listener: (this: HTMLAthCardElement, ev: AthCardCustomEvent<HTMLAthCardElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthCardElement: {
        prototype: HTMLAthCardElement;
        new (): HTMLAthCardElement;
    };
    interface HTMLAthCardHeaderElement extends Components.AthCardHeader, HTMLStencilElement {
    }
    var HTMLAthCardHeaderElement: {
        prototype: HTMLAthCardHeaderElement;
        new (): HTMLAthCardHeaderElement;
    };
    interface HTMLAthCardSelectableElementEventMap {
        "athChange": any;
        "athFocus": void;
        "athBlur": void;
    }
    interface HTMLAthCardSelectableElement extends Components.AthCardSelectable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthCardSelectableElementEventMap>(type: K, listener: (this: HTMLAthCardSelectableElement, ev: AthCardSelectableCustomEvent<HTMLAthCardSelectableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthCardSelectableElementEventMap>(type: K, listener: (this: HTMLAthCardSelectableElement, ev: AthCardSelectableCustomEvent<HTMLAthCardSelectableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthCardSelectableElement: {
        prototype: HTMLAthCardSelectableElement;
        new (): HTMLAthCardSelectableElement;
    };
    interface HTMLAthCardSelectableGroupElementEventMap {
        "athValueChanged": HTMLAthCardSelectableElement[];
    }
    interface HTMLAthCardSelectableGroupElement extends Components.AthCardSelectableGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthCardSelectableGroupElementEventMap>(type: K, listener: (this: HTMLAthCardSelectableGroupElement, ev: AthCardSelectableGroupCustomEvent<HTMLAthCardSelectableGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthCardSelectableGroupElementEventMap>(type: K, listener: (this: HTMLAthCardSelectableGroupElement, ev: AthCardSelectableGroupCustomEvent<HTMLAthCardSelectableGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthCardSelectableGroupElement: {
        prototype: HTMLAthCardSelectableGroupElement;
        new (): HTMLAthCardSelectableGroupElement;
    };
    interface HTMLAthCardThumbnailElement extends Components.AthCardThumbnail, HTMLStencilElement {
    }
    var HTMLAthCardThumbnailElement: {
        prototype: HTMLAthCardThumbnailElement;
        new (): HTMLAthCardThumbnailElement;
    };
    interface HTMLAthCheckboxElementEventMap {
        "athFocus": void;
        "athBlur": void;
        "athChange": CheckboxChangeEventDetail;
    }
    interface HTMLAthCheckboxElement extends Components.AthCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthCheckboxElementEventMap>(type: K, listener: (this: HTMLAthCheckboxElement, ev: AthCheckboxCustomEvent<HTMLAthCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthCheckboxElementEventMap>(type: K, listener: (this: HTMLAthCheckboxElement, ev: AthCheckboxCustomEvent<HTMLAthCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthCheckboxElement: {
        prototype: HTMLAthCheckboxElement;
        new (): HTMLAthCheckboxElement;
    };
    interface HTMLAthCheckboxGroupElementEventMap {
        "athChecked": CheckboxChangeEventDetail[];
    }
    interface HTMLAthCheckboxGroupElement extends Components.AthCheckboxGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLAthCheckboxGroupElement, ev: AthCheckboxGroupCustomEvent<HTMLAthCheckboxGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLAthCheckboxGroupElement, ev: AthCheckboxGroupCustomEvent<HTMLAthCheckboxGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthCheckboxGroupElement: {
        prototype: HTMLAthCheckboxGroupElement;
        new (): HTMLAthCheckboxGroupElement;
    };
    interface HTMLAthChipChoiceElementEventMap {
        "athChange": any;
        "athFocus": void;
        "athBlur": void;
    }
    interface HTMLAthChipChoiceElement extends Components.AthChipChoice, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthChipChoiceElementEventMap>(type: K, listener: (this: HTMLAthChipChoiceElement, ev: AthChipChoiceCustomEvent<HTMLAthChipChoiceElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthChipChoiceElementEventMap>(type: K, listener: (this: HTMLAthChipChoiceElement, ev: AthChipChoiceCustomEvent<HTMLAthChipChoiceElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthChipChoiceElement: {
        prototype: HTMLAthChipChoiceElement;
        new (): HTMLAthChipChoiceElement;
    };
    interface HTMLAthChipChoiceGroupElementEventMap {
        "athChangeValue": HTMLAthChipChoiceElement[];
    }
    interface HTMLAthChipChoiceGroupElement extends Components.AthChipChoiceGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthChipChoiceGroupElementEventMap>(type: K, listener: (this: HTMLAthChipChoiceGroupElement, ev: AthChipChoiceGroupCustomEvent<HTMLAthChipChoiceGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthChipChoiceGroupElementEventMap>(type: K, listener: (this: HTMLAthChipChoiceGroupElement, ev: AthChipChoiceGroupCustomEvent<HTMLAthChipChoiceGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthChipChoiceGroupElement: {
        prototype: HTMLAthChipChoiceGroupElement;
        new (): HTMLAthChipChoiceGroupElement;
    };
    interface HTMLAthChipDismissElementEventMap {
        "athDismiss": void;
    }
    interface HTMLAthChipDismissElement extends Components.AthChipDismiss, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthChipDismissElementEventMap>(type: K, listener: (this: HTMLAthChipDismissElement, ev: AthChipDismissCustomEvent<HTMLAthChipDismissElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthChipDismissElementEventMap>(type: K, listener: (this: HTMLAthChipDismissElement, ev: AthChipDismissCustomEvent<HTMLAthChipDismissElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthChipDismissElement: {
        prototype: HTMLAthChipDismissElement;
        new (): HTMLAthChipDismissElement;
    };
    interface HTMLAthChipDismissGroupElement extends Components.AthChipDismissGroup, HTMLStencilElement {
    }
    var HTMLAthChipDismissGroupElement: {
        prototype: HTMLAthChipDismissGroupElement;
        new (): HTMLAthChipDismissGroupElement;
    };
    interface HTMLAthCollapseElementEventMap {
        "athCollapseState": { id: string; isExpanded: boolean };
    }
    interface HTMLAthCollapseElement extends Components.AthCollapse, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthCollapseElementEventMap>(type: K, listener: (this: HTMLAthCollapseElement, ev: AthCollapseCustomEvent<HTMLAthCollapseElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthCollapseElementEventMap>(type: K, listener: (this: HTMLAthCollapseElement, ev: AthCollapseCustomEvent<HTMLAthCollapseElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthCollapseElement: {
        prototype: HTMLAthCollapseElement;
        new (): HTMLAthCollapseElement;
    };
    interface HTMLAthCollapseIconElement extends Components.AthCollapseIcon, HTMLStencilElement {
    }
    var HTMLAthCollapseIconElement: {
        prototype: HTMLAthCollapseIconElement;
        new (): HTMLAthCollapseIconElement;
    };
    interface HTMLAthDatepickerElementEventMap {
        "athFocus": void;
        "athBlur": void;
        "athChange": string;
        "athInput": string;
    }
    interface HTMLAthDatepickerElement extends Components.AthDatepicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthDatepickerElementEventMap>(type: K, listener: (this: HTMLAthDatepickerElement, ev: AthDatepickerCustomEvent<HTMLAthDatepickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthDatepickerElementEventMap>(type: K, listener: (this: HTMLAthDatepickerElement, ev: AthDatepickerCustomEvent<HTMLAthDatepickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthDatepickerElement: {
        prototype: HTMLAthDatepickerElement;
        new (): HTMLAthDatepickerElement;
    };
    interface HTMLAthDatepickerRangeElementEventMap {
        "athFocus": void;
        "athBlur": void;
        "athChange": string;
    }
    interface HTMLAthDatepickerRangeElement extends Components.AthDatepickerRange, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthDatepickerRangeElementEventMap>(type: K, listener: (this: HTMLAthDatepickerRangeElement, ev: AthDatepickerRangeCustomEvent<HTMLAthDatepickerRangeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthDatepickerRangeElementEventMap>(type: K, listener: (this: HTMLAthDatepickerRangeElement, ev: AthDatepickerRangeCustomEvent<HTMLAthDatepickerRangeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthDatepickerRangeElement: {
        prototype: HTMLAthDatepickerRangeElement;
        new (): HTMLAthDatepickerRangeElement;
    };
    interface HTMLAthDividerElement extends Components.AthDivider, HTMLStencilElement {
    }
    var HTMLAthDividerElement: {
        prototype: HTMLAthDividerElement;
        new (): HTMLAthDividerElement;
    };
    interface HTMLAthDropdownElementEventMap {
        "athChange": ActionListItem[];
        "athFocus": void;
        "athBlur": void;
    }
    interface HTMLAthDropdownElement extends Components.AthDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthDropdownElementEventMap>(type: K, listener: (this: HTMLAthDropdownElement, ev: AthDropdownCustomEvent<HTMLAthDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthDropdownElementEventMap>(type: K, listener: (this: HTMLAthDropdownElement, ev: AthDropdownCustomEvent<HTMLAthDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthDropdownElement: {
        prototype: HTMLAthDropdownElement;
        new (): HTMLAthDropdownElement;
    };
    interface HTMLAthDropdownOptionElementEventMap {
        "optSelected": { source: 'user' | 'programmatic' };
    }
    interface HTMLAthDropdownOptionElement extends Components.AthDropdownOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthDropdownOptionElementEventMap>(type: K, listener: (this: HTMLAthDropdownOptionElement, ev: AthDropdownOptionCustomEvent<HTMLAthDropdownOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthDropdownOptionElementEventMap>(type: K, listener: (this: HTMLAthDropdownOptionElement, ev: AthDropdownOptionCustomEvent<HTMLAthDropdownOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthDropdownOptionElement: {
        prototype: HTMLAthDropdownOptionElement;
        new (): HTMLAthDropdownOptionElement;
    };
    interface HTMLAthEmptyStateElement extends Components.AthEmptyState, HTMLStencilElement {
    }
    var HTMLAthEmptyStateElement: {
        prototype: HTMLAthEmptyStateElement;
        new (): HTMLAthEmptyStateElement;
    };
    interface HTMLAthIconElement extends Components.AthIcon, HTMLStencilElement {
    }
    var HTMLAthIconElement: {
        prototype: HTMLAthIconElement;
        new (): HTMLAthIconElement;
    };
    interface HTMLAthInputCounterElementEventMap {
        "athFocus": void;
        "athBlur": void;
        "athChange": string;
        "athInput": string;
    }
    interface HTMLAthInputCounterElement extends Components.AthInputCounter, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthInputCounterElementEventMap>(type: K, listener: (this: HTMLAthInputCounterElement, ev: AthInputCounterCustomEvent<HTMLAthInputCounterElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthInputCounterElementEventMap>(type: K, listener: (this: HTMLAthInputCounterElement, ev: AthInputCounterCustomEvent<HTMLAthInputCounterElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthInputCounterElement: {
        prototype: HTMLAthInputCounterElement;
        new (): HTMLAthInputCounterElement;
    };
    interface HTMLAthInputPasswordElementEventMap {
        "athFocus": void;
        "athBlur": void;
        "athChange": string;
        "athClear": string;
        "athInput": string;
    }
    interface HTMLAthInputPasswordElement extends Components.AthInputPassword, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthInputPasswordElementEventMap>(type: K, listener: (this: HTMLAthInputPasswordElement, ev: AthInputPasswordCustomEvent<HTMLAthInputPasswordElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthInputPasswordElementEventMap>(type: K, listener: (this: HTMLAthInputPasswordElement, ev: AthInputPasswordCustomEvent<HTMLAthInputPasswordElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthInputPasswordElement: {
        prototype: HTMLAthInputPasswordElement;
        new (): HTMLAthInputPasswordElement;
    };
    interface HTMLAthInputTextElementEventMap {
        "athFocus": void;
        "athBlur": void;
        "athChange": string;
        "athClear": string;
        "athInput": string;
    }
    interface HTMLAthInputTextElement extends Components.AthInputText, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthInputTextElementEventMap>(type: K, listener: (this: HTMLAthInputTextElement, ev: AthInputTextCustomEvent<HTMLAthInputTextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthInputTextElementEventMap>(type: K, listener: (this: HTMLAthInputTextElement, ev: AthInputTextCustomEvent<HTMLAthInputTextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthInputTextElement: {
        prototype: HTMLAthInputTextElement;
        new (): HTMLAthInputTextElement;
    };
    interface HTMLAthInputTextareaElementEventMap {
        "athFocus": void;
        "athBlur": void;
        "athChange": string;
        "athInput": string;
    }
    interface HTMLAthInputTextareaElement extends Components.AthInputTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthInputTextareaElementEventMap>(type: K, listener: (this: HTMLAthInputTextareaElement, ev: AthInputTextareaCustomEvent<HTMLAthInputTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthInputTextareaElementEventMap>(type: K, listener: (this: HTMLAthInputTextareaElement, ev: AthInputTextareaCustomEvent<HTMLAthInputTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthInputTextareaElement: {
        prototype: HTMLAthInputTextareaElement;
        new (): HTMLAthInputTextareaElement;
    };
    interface HTMLAthLinkElementEventMap {
        "athClick": void;
        "athFocus": void;
        "athBlur": void;
    }
    interface HTMLAthLinkElement extends Components.AthLink, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthLinkElementEventMap>(type: K, listener: (this: HTMLAthLinkElement, ev: AthLinkCustomEvent<HTMLAthLinkElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthLinkElementEventMap>(type: K, listener: (this: HTMLAthLinkElement, ev: AthLinkCustomEvent<HTMLAthLinkElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthLinkElement: {
        prototype: HTMLAthLinkElement;
        new (): HTMLAthLinkElement;
    };
    interface HTMLAthListElement extends Components.AthList, HTMLStencilElement {
    }
    var HTMLAthListElement: {
        prototype: HTMLAthListElement;
        new (): HTMLAthListElement;
    };
    interface HTMLAthListItemElementEventMap {
        "athClick": void;
    }
    interface HTMLAthListItemElement extends Components.AthListItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthListItemElementEventMap>(type: K, listener: (this: HTMLAthListItemElement, ev: AthListItemCustomEvent<HTMLAthListItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthListItemElementEventMap>(type: K, listener: (this: HTMLAthListItemElement, ev: AthListItemCustomEvent<HTMLAthListItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthListItemElement: {
        prototype: HTMLAthListItemElement;
        new (): HTMLAthListItemElement;
    };
    interface HTMLAthMenuButtonElementEventMap {
        "athAction": { item: HTMLAthMenuButtonItemElement };
    }
    interface HTMLAthMenuButtonElement extends Components.AthMenuButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthMenuButtonElementEventMap>(type: K, listener: (this: HTMLAthMenuButtonElement, ev: AthMenuButtonCustomEvent<HTMLAthMenuButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthMenuButtonElementEventMap>(type: K, listener: (this: HTMLAthMenuButtonElement, ev: AthMenuButtonCustomEvent<HTMLAthMenuButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthMenuButtonElement: {
        prototype: HTMLAthMenuButtonElement;
        new (): HTMLAthMenuButtonElement;
    };
    interface HTMLAthMenuButtonItemElementEventMap {
        "athSelected": HTMLAthMenuButtonItemElement;
    }
    interface HTMLAthMenuButtonItemElement extends Components.AthMenuButtonItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthMenuButtonItemElementEventMap>(type: K, listener: (this: HTMLAthMenuButtonItemElement, ev: AthMenuButtonItemCustomEvent<HTMLAthMenuButtonItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthMenuButtonItemElementEventMap>(type: K, listener: (this: HTMLAthMenuButtonItemElement, ev: AthMenuButtonItemCustomEvent<HTMLAthMenuButtonItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthMenuButtonItemElement: {
        prototype: HTMLAthMenuButtonItemElement;
        new (): HTMLAthMenuButtonItemElement;
    };
    interface HTMLAthMenuHorizontalElementEventMap {
        "athSelected": MenuHorizontalItem;
    }
    interface HTMLAthMenuHorizontalElement extends Components.AthMenuHorizontal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthMenuHorizontalElementEventMap>(type: K, listener: (this: HTMLAthMenuHorizontalElement, ev: AthMenuHorizontalCustomEvent<HTMLAthMenuHorizontalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthMenuHorizontalElementEventMap>(type: K, listener: (this: HTMLAthMenuHorizontalElement, ev: AthMenuHorizontalCustomEvent<HTMLAthMenuHorizontalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthMenuHorizontalElement: {
        prototype: HTMLAthMenuHorizontalElement;
        new (): HTMLAthMenuHorizontalElement;
    };
    interface HTMLAthMenuHorizontalItemElement extends Components.AthMenuHorizontalItem, HTMLStencilElement {
    }
    var HTMLAthMenuHorizontalItemElement: {
        prototype: HTMLAthMenuHorizontalItemElement;
        new (): HTMLAthMenuHorizontalItemElement;
    };
    interface HTMLAthMenuLateralElementEventMap {
        "athSelected": { item: HTMLAthMenuLateralItemActionElement | HTMLAthMenuLateralItemLinkElement };
    }
    interface HTMLAthMenuLateralElement extends Components.AthMenuLateral, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthMenuLateralElementEventMap>(type: K, listener: (this: HTMLAthMenuLateralElement, ev: AthMenuLateralCustomEvent<HTMLAthMenuLateralElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthMenuLateralElementEventMap>(type: K, listener: (this: HTMLAthMenuLateralElement, ev: AthMenuLateralCustomEvent<HTMLAthMenuLateralElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthMenuLateralElement: {
        prototype: HTMLAthMenuLateralElement;
        new (): HTMLAthMenuLateralElement;
    };
    interface HTMLAthMenuLateralItemActionElement extends Components.AthMenuLateralItemAction, HTMLStencilElement {
    }
    var HTMLAthMenuLateralItemActionElement: {
        prototype: HTMLAthMenuLateralItemActionElement;
        new (): HTMLAthMenuLateralItemActionElement;
    };
    interface HTMLAthMenuLateralItemLinkElement extends Components.AthMenuLateralItemLink, HTMLStencilElement {
    }
    var HTMLAthMenuLateralItemLinkElement: {
        prototype: HTMLAthMenuLateralItemLinkElement;
        new (): HTMLAthMenuLateralItemLinkElement;
    };
    interface HTMLAthMenuVerticalElementEventMap {
        "athSelected": MenuItem;
    }
    interface HTMLAthMenuVerticalElement extends Components.AthMenuVertical, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthMenuVerticalElementEventMap>(type: K, listener: (this: HTMLAthMenuVerticalElement, ev: AthMenuVerticalCustomEvent<HTMLAthMenuVerticalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthMenuVerticalElementEventMap>(type: K, listener: (this: HTMLAthMenuVerticalElement, ev: AthMenuVerticalCustomEvent<HTMLAthMenuVerticalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthMenuVerticalElement: {
        prototype: HTMLAthMenuVerticalElement;
        new (): HTMLAthMenuVerticalElement;
    };
    interface HTMLAthMenuVerticalItemActionElement extends Components.AthMenuVerticalItemAction, HTMLStencilElement {
    }
    var HTMLAthMenuVerticalItemActionElement: {
        prototype: HTMLAthMenuVerticalItemActionElement;
        new (): HTMLAthMenuVerticalItemActionElement;
    };
    interface HTMLAthMenuVerticalItemLinkElement extends Components.AthMenuVerticalItemLink, HTMLStencilElement {
    }
    var HTMLAthMenuVerticalItemLinkElement: {
        prototype: HTMLAthMenuVerticalItemLinkElement;
        new (): HTMLAthMenuVerticalItemLinkElement;
    };
    interface HTMLAthModalElementEventMap {
        "athOpened": void;
        "athClosed": void;
    }
    interface HTMLAthModalElement extends Components.AthModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthModalElementEventMap>(type: K, listener: (this: HTMLAthModalElement, ev: AthModalCustomEvent<HTMLAthModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthModalElementEventMap>(type: K, listener: (this: HTMLAthModalElement, ev: AthModalCustomEvent<HTMLAthModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthModalElement: {
        prototype: HTMLAthModalElement;
        new (): HTMLAthModalElement;
    };
    interface HTMLAthPaginationElementEventMap {
        "athPaginate": number;
        "athItemsPerPageChange": number;
    }
    interface HTMLAthPaginationElement extends Components.AthPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthPaginationElementEventMap>(type: K, listener: (this: HTMLAthPaginationElement, ev: AthPaginationCustomEvent<HTMLAthPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthPaginationElementEventMap>(type: K, listener: (this: HTMLAthPaginationElement, ev: AthPaginationCustomEvent<HTMLAthPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthPaginationElement: {
        prototype: HTMLAthPaginationElement;
        new (): HTMLAthPaginationElement;
    };
    interface HTMLAthPanelElement extends Components.AthPanel, HTMLStencilElement {
    }
    var HTMLAthPanelElement: {
        prototype: HTMLAthPanelElement;
        new (): HTMLAthPanelElement;
    };
    interface HTMLAthPictogramElement extends Components.AthPictogram, HTMLStencilElement {
    }
    var HTMLAthPictogramElement: {
        prototype: HTMLAthPictogramElement;
        new (): HTMLAthPictogramElement;
    };
    interface HTMLAthProgressBarElement extends Components.AthProgressBar, HTMLStencilElement {
    }
    var HTMLAthProgressBarElement: {
        prototype: HTMLAthProgressBarElement;
        new (): HTMLAthProgressBarElement;
    };
    interface HTMLAthRadioButtonElementEventMap {
        "athFocus": void;
        "athBlur": void;
        "athChange": RadioButtonChangeDetail;
    }
    interface HTMLAthRadioButtonElement extends Components.AthRadioButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthRadioButtonElementEventMap>(type: K, listener: (this: HTMLAthRadioButtonElement, ev: AthRadioButtonCustomEvent<HTMLAthRadioButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthRadioButtonElementEventMap>(type: K, listener: (this: HTMLAthRadioButtonElement, ev: AthRadioButtonCustomEvent<HTMLAthRadioButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthRadioButtonElement: {
        prototype: HTMLAthRadioButtonElement;
        new (): HTMLAthRadioButtonElement;
    };
    interface HTMLAthRadioButtonGroupElementEventMap {
        "athChangeValue": string;
    }
    interface HTMLAthRadioButtonGroupElement extends Components.AthRadioButtonGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthRadioButtonGroupElementEventMap>(type: K, listener: (this: HTMLAthRadioButtonGroupElement, ev: AthRadioButtonGroupCustomEvent<HTMLAthRadioButtonGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthRadioButtonGroupElementEventMap>(type: K, listener: (this: HTMLAthRadioButtonGroupElement, ev: AthRadioButtonGroupCustomEvent<HTMLAthRadioButtonGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthRadioButtonGroupElement: {
        prototype: HTMLAthRadioButtonGroupElement;
        new (): HTMLAthRadioButtonGroupElement;
    };
    interface HTMLAthSectionTitleElementEventMap {
        "athToggleCollapse": string;
    }
    interface HTMLAthSectionTitleElement extends Components.AthSectionTitle, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthSectionTitleElementEventMap>(type: K, listener: (this: HTMLAthSectionTitleElement, ev: AthSectionTitleCustomEvent<HTMLAthSectionTitleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthSectionTitleElementEventMap>(type: K, listener: (this: HTMLAthSectionTitleElement, ev: AthSectionTitleCustomEvent<HTMLAthSectionTitleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthSectionTitleElement: {
        prototype: HTMLAthSectionTitleElement;
        new (): HTMLAthSectionTitleElement;
    };
    interface HTMLAthSegmentedControlElementEventMap {
        "athChangeValue": HTMLAthSegmentedControlItemElement;
    }
    interface HTMLAthSegmentedControlElement extends Components.AthSegmentedControl, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthSegmentedControlElementEventMap>(type: K, listener: (this: HTMLAthSegmentedControlElement, ev: AthSegmentedControlCustomEvent<HTMLAthSegmentedControlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthSegmentedControlElementEventMap>(type: K, listener: (this: HTMLAthSegmentedControlElement, ev: AthSegmentedControlCustomEvent<HTMLAthSegmentedControlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthSegmentedControlElement: {
        prototype: HTMLAthSegmentedControlElement;
        new (): HTMLAthSegmentedControlElement;
    };
    interface HTMLAthSegmentedControlItemElementEventMap {
        "athFocus": void;
        "athChange": SegmentedControlItemChangeSelect;
    }
    interface HTMLAthSegmentedControlItemElement extends Components.AthSegmentedControlItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthSegmentedControlItemElementEventMap>(type: K, listener: (this: HTMLAthSegmentedControlItemElement, ev: AthSegmentedControlItemCustomEvent<HTMLAthSegmentedControlItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthSegmentedControlItemElementEventMap>(type: K, listener: (this: HTMLAthSegmentedControlItemElement, ev: AthSegmentedControlItemCustomEvent<HTMLAthSegmentedControlItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthSegmentedControlItemElement: {
        prototype: HTMLAthSegmentedControlItemElement;
        new (): HTMLAthSegmentedControlItemElement;
    };
    interface HTMLAthSliderElementEventMap {
        "athChange": string;
        "athFocus": void;
        "athBlur": void;
    }
    interface HTMLAthSliderElement extends Components.AthSlider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthSliderElementEventMap>(type: K, listener: (this: HTMLAthSliderElement, ev: AthSliderCustomEvent<HTMLAthSliderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthSliderElementEventMap>(type: K, listener: (this: HTMLAthSliderElement, ev: AthSliderCustomEvent<HTMLAthSliderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthSliderElement: {
        prototype: HTMLAthSliderElement;
        new (): HTMLAthSliderElement;
    };
    interface HTMLAthStepElementEventMap {
        "athClick": number;
    }
    interface HTMLAthStepElement extends Components.AthStep, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthStepElementEventMap>(type: K, listener: (this: HTMLAthStepElement, ev: AthStepCustomEvent<HTMLAthStepElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthStepElementEventMap>(type: K, listener: (this: HTMLAthStepElement, ev: AthStepCustomEvent<HTMLAthStepElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthStepElement: {
        prototype: HTMLAthStepElement;
        new (): HTMLAthStepElement;
    };
    interface HTMLAthStepperElementEventMap {
        "athSelect": HTMLAthStepElement;
    }
    interface HTMLAthStepperElement extends Components.AthStepper, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthStepperElementEventMap>(type: K, listener: (this: HTMLAthStepperElement, ev: AthStepperCustomEvent<HTMLAthStepperElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthStepperElementEventMap>(type: K, listener: (this: HTMLAthStepperElement, ev: AthStepperCustomEvent<HTMLAthStepperElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthStepperElement: {
        prototype: HTMLAthStepperElement;
        new (): HTMLAthStepperElement;
    };
    interface HTMLAthSwitchElementEventMap {
        "athFocus": void;
        "athBlur": void;
        "athChange": SwitchChangeDetail;
    }
    interface HTMLAthSwitchElement extends Components.AthSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthSwitchElementEventMap>(type: K, listener: (this: HTMLAthSwitchElement, ev: AthSwitchCustomEvent<HTMLAthSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthSwitchElementEventMap>(type: K, listener: (this: HTMLAthSwitchElement, ev: AthSwitchCustomEvent<HTMLAthSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthSwitchElement: {
        prototype: HTMLAthSwitchElement;
        new (): HTMLAthSwitchElement;
    };
    interface HTMLAthTabElement extends Components.AthTab, HTMLStencilElement {
    }
    var HTMLAthTabElement: {
        prototype: HTMLAthTabElement;
        new (): HTMLAthTabElement;
    };
    interface HTMLAthTableElementEventMap {
        "athSelectionChange": TableSelectionChangeEvent;
        "athTableClick": TableClickEvent;
    }
    interface HTMLAthTableElement extends Components.AthTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthTableElementEventMap>(type: K, listener: (this: HTMLAthTableElement, ev: AthTableCustomEvent<HTMLAthTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthTableElementEventMap>(type: K, listener: (this: HTMLAthTableElement, ev: AthTableCustomEvent<HTMLAthTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthTableElement: {
        prototype: HTMLAthTableElement;
        new (): HTMLAthTableElement;
    };
    interface HTMLAthTableBodyElement extends Components.AthTableBody, HTMLStencilElement {
    }
    var HTMLAthTableBodyElement: {
        prototype: HTMLAthTableBodyElement;
        new (): HTMLAthTableBodyElement;
    };
    interface HTMLAthTableHeaderElementEventMap {
        "athSelectAllChange": TableSelectAllChangeEvent;
    }
    interface HTMLAthTableHeaderElement extends Components.AthTableHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthTableHeaderElementEventMap>(type: K, listener: (this: HTMLAthTableHeaderElement, ev: AthTableHeaderCustomEvent<HTMLAthTableHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthTableHeaderElementEventMap>(type: K, listener: (this: HTMLAthTableHeaderElement, ev: AthTableHeaderCustomEvent<HTMLAthTableHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthTableHeaderElement: {
        prototype: HTMLAthTableHeaderElement;
        new (): HTMLAthTableHeaderElement;
    };
    interface HTMLAthTableHeaderItemElement extends Components.AthTableHeaderItem, HTMLStencilElement {
    }
    var HTMLAthTableHeaderItemElement: {
        prototype: HTMLAthTableHeaderItemElement;
        new (): HTMLAthTableHeaderItemElement;
    };
    interface HTMLAthTableRowElementEventMap {
        "athRowSelectionChange": TableRowSelectionChangeEvent;
        "athRowClick": TableRowClickEvent;
    }
    interface HTMLAthTableRowElement extends Components.AthTableRow, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthTableRowElementEventMap>(type: K, listener: (this: HTMLAthTableRowElement, ev: AthTableRowCustomEvent<HTMLAthTableRowElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthTableRowElementEventMap>(type: K, listener: (this: HTMLAthTableRowElement, ev: AthTableRowCustomEvent<HTMLAthTableRowElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthTableRowElement: {
        prototype: HTMLAthTableRowElement;
        new (): HTMLAthTableRowElement;
    };
    interface HTMLAthTableRowItemElement extends Components.AthTableRowItem, HTMLStencilElement {
    }
    var HTMLAthTableRowItemElement: {
        prototype: HTMLAthTableRowItemElement;
        new (): HTMLAthTableRowItemElement;
    };
    interface HTMLAthTabsElement extends Components.AthTabs, HTMLStencilElement {
    }
    var HTMLAthTabsElement: {
        prototype: HTMLAthTabsElement;
        new (): HTMLAthTabsElement;
    };
    interface HTMLAthTagElement extends Components.AthTag, HTMLStencilElement {
    }
    var HTMLAthTagElement: {
        prototype: HTMLAthTagElement;
        new (): HTMLAthTagElement;
    };
    interface HTMLAthTextElement extends Components.AthText, HTMLStencilElement {
    }
    var HTMLAthTextElement: {
        prototype: HTMLAthTextElement;
        new (): HTMLAthTextElement;
    };
    interface HTMLAthTooltipElement extends Components.AthTooltip, HTMLStencilElement {
    }
    var HTMLAthTooltipElement: {
        prototype: HTMLAthTooltipElement;
        new (): HTMLAthTooltipElement;
    };
    interface HTMLAthTooltipTriggerElementEventMap {
        "athClick": void;
        "athFocus": void;
        "athBlur": void;
    }
    interface HTMLAthTooltipTriggerElement extends Components.AthTooltipTrigger, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthTooltipTriggerElementEventMap>(type: K, listener: (this: HTMLAthTooltipTriggerElement, ev: AthTooltipTriggerCustomEvent<HTMLAthTooltipTriggerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthTooltipTriggerElementEventMap>(type: K, listener: (this: HTMLAthTooltipTriggerElement, ev: AthTooltipTriggerCustomEvent<HTMLAthTooltipTriggerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthTooltipTriggerElement: {
        prototype: HTMLAthTooltipTriggerElement;
        new (): HTMLAthTooltipTriggerElement;
    };
    interface HTMLAthUserDetailElementEventMap {
        "athAction": void;
    }
    interface HTMLAthUserDetailElement extends Components.AthUserDetail, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthUserDetailElementEventMap>(type: K, listener: (this: HTMLAthUserDetailElement, ev: AthUserDetailCustomEvent<HTMLAthUserDetailElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthUserDetailElementEventMap>(type: K, listener: (this: HTMLAthUserDetailElement, ev: AthUserDetailCustomEvent<HTMLAthUserDetailElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthUserDetailElement: {
        prototype: HTMLAthUserDetailElement;
        new (): HTMLAthUserDetailElement;
    };
    interface HTMLAthUserMenuElementEventMap {
        "athAction": { item: HTMLAthMenuButtonItemElement };
    }
    interface HTMLAthUserMenuElement extends Components.AthUserMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAthUserMenuElementEventMap>(type: K, listener: (this: HTMLAthUserMenuElement, ev: AthUserMenuCustomEvent<HTMLAthUserMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAthUserMenuElementEventMap>(type: K, listener: (this: HTMLAthUserMenuElement, ev: AthUserMenuCustomEvent<HTMLAthUserMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAthUserMenuElement: {
        prototype: HTMLAthUserMenuElement;
        new (): HTMLAthUserMenuElement;
    };
    interface HTMLElementTagNameMap {
        "ath-accordion": HTMLAthAccordionElement;
        "ath-accordion-item": HTMLAthAccordionItemElement;
        "ath-action-bar": HTMLAthActionBarElement;
        "ath-alert": HTMLAthAlertElement;
        "ath-avatar": HTMLAthAvatarElement;
        "ath-badge": HTMLAthBadgeElement;
        "ath-breadcrumb": HTMLAthBreadcrumbElement;
        "ath-button": HTMLAthButtonElement;
        "ath-button-expandable": HTMLAthButtonExpandableElement;
        "ath-button-link": HTMLAthButtonLinkElement;
        "ath-calendar": HTMLAthCalendarElement;
        "ath-card": HTMLAthCardElement;
        "ath-card-header": HTMLAthCardHeaderElement;
        "ath-card-selectable": HTMLAthCardSelectableElement;
        "ath-card-selectable-group": HTMLAthCardSelectableGroupElement;
        "ath-card-thumbnail": HTMLAthCardThumbnailElement;
        "ath-checkbox": HTMLAthCheckboxElement;
        "ath-checkbox-group": HTMLAthCheckboxGroupElement;
        "ath-chip-choice": HTMLAthChipChoiceElement;
        "ath-chip-choice-group": HTMLAthChipChoiceGroupElement;
        "ath-chip-dismiss": HTMLAthChipDismissElement;
        "ath-chip-dismiss-group": HTMLAthChipDismissGroupElement;
        "ath-collapse": HTMLAthCollapseElement;
        "ath-collapse-icon": HTMLAthCollapseIconElement;
        "ath-datepicker": HTMLAthDatepickerElement;
        "ath-datepicker-range": HTMLAthDatepickerRangeElement;
        "ath-divider": HTMLAthDividerElement;
        "ath-dropdown": HTMLAthDropdownElement;
        "ath-dropdown-option": HTMLAthDropdownOptionElement;
        "ath-empty-state": HTMLAthEmptyStateElement;
        "ath-icon": HTMLAthIconElement;
        "ath-input-counter": HTMLAthInputCounterElement;
        "ath-input-password": HTMLAthInputPasswordElement;
        "ath-input-text": HTMLAthInputTextElement;
        "ath-input-textarea": HTMLAthInputTextareaElement;
        "ath-link": HTMLAthLinkElement;
        "ath-list": HTMLAthListElement;
        "ath-list-item": HTMLAthListItemElement;
        "ath-menu-button": HTMLAthMenuButtonElement;
        "ath-menu-button-item": HTMLAthMenuButtonItemElement;
        "ath-menu-horizontal": HTMLAthMenuHorizontalElement;
        "ath-menu-horizontal-item": HTMLAthMenuHorizontalItemElement;
        "ath-menu-lateral": HTMLAthMenuLateralElement;
        "ath-menu-lateral-item-action": HTMLAthMenuLateralItemActionElement;
        "ath-menu-lateral-item-link": HTMLAthMenuLateralItemLinkElement;
        "ath-menu-vertical": HTMLAthMenuVerticalElement;
        "ath-menu-vertical-item-action": HTMLAthMenuVerticalItemActionElement;
        "ath-menu-vertical-item-link": HTMLAthMenuVerticalItemLinkElement;
        "ath-modal": HTMLAthModalElement;
        "ath-pagination": HTMLAthPaginationElement;
        "ath-panel": HTMLAthPanelElement;
        "ath-pictogram": HTMLAthPictogramElement;
        "ath-progress-bar": HTMLAthProgressBarElement;
        "ath-radio-button": HTMLAthRadioButtonElement;
        "ath-radio-button-group": HTMLAthRadioButtonGroupElement;
        "ath-section-title": HTMLAthSectionTitleElement;
        "ath-segmented-control": HTMLAthSegmentedControlElement;
        "ath-segmented-control-item": HTMLAthSegmentedControlItemElement;
        "ath-slider": HTMLAthSliderElement;
        "ath-step": HTMLAthStepElement;
        "ath-stepper": HTMLAthStepperElement;
        "ath-switch": HTMLAthSwitchElement;
        "ath-tab": HTMLAthTabElement;
        "ath-table": HTMLAthTableElement;
        "ath-table-body": HTMLAthTableBodyElement;
        "ath-table-header": HTMLAthTableHeaderElement;
        "ath-table-header-item": HTMLAthTableHeaderItemElement;
        "ath-table-row": HTMLAthTableRowElement;
        "ath-table-row-item": HTMLAthTableRowItemElement;
        "ath-tabs": HTMLAthTabsElement;
        "ath-tag": HTMLAthTagElement;
        "ath-text": HTMLAthTextElement;
        "ath-tooltip": HTMLAthTooltipElement;
        "ath-tooltip-trigger": HTMLAthTooltipTriggerElement;
        "ath-user-detail": HTMLAthUserDetailElement;
        "ath-user-menu": HTMLAthUserMenuElement;
    }
}
declare namespace LocalJSX {
    interface AthAccordion {
        /**
          * Indica una etiqueta accesible para el acordeón
         */
        "ariaLabel"?: string | null;
        /**
          * Indica si se pueden abrir todos los elementos al mismo tiempo
          * @default AccordionExpands.All
         */
        "expand"?: AccordionExpand;
        /**
          * Si es true, se muestra el divisor también en el último ítem.
          * @default false
         */
        "noLastItemDivider"?: boolean;
    }
    interface AthAccordionItem {
        /**
          * Descriprion of heading item
         */
        "description"?: string;
        /**
          * The accordion item is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The accordion item is expanded
          * @default false
         */
        "expanded"?: boolean;
        /**
          * The accordion item aria-level
          * @default '2'
         */
        "headingLevel"?: string;
        /**
          * Title of heading item
         */
        "headingText"?: string;
        /**
          * The code of the accordion item's icon
         */
        "icon"?: string;
        /**
          * The accordion item divider bottom
          * @default false
         */
        "noDivider"?: boolean;
        "onOpened"?: (event: AthAccordionItemCustomEvent<void>) => void;
    }
    interface AthActionBar {
        /**
          * Indicates the alignment of the inner components
          * @default ActionBarAlignments.Left
         */
        "alignment"?: ActionBarAlignment;
        /**
          * Indicates the size of the inner components
          * @default ActionBarSizes.Medium
         */
        "size"?: ActionBarSize;
    }
    interface AthAlert {
        /**
          * Close button aria-label
          * @default 'Cerrar alerta'
         */
        "closeAriaLabel"?: string;
        /**
          * The color of the message
          * @default AlertColor.Info
         */
        "color"?: AlertColors;
        /**
          * Descripcion del alert
         */
        "description"?: string;
        /**
          * Has button close
          * @default true
         */
        "hasClose"?: boolean;
        /**
          * Nivel de heading del título
          * @default 6
         */
        "headingLevel"?: number;
        /**
          * Titulo del alert
         */
        "headingText"?: string;
        /**
          * Titulo del alert
          * @default false
         */
        "isUrgent"?: boolean;
        /**
          * Tipo de alert
          * @default AlertType.Section
         */
        "type"?: AlertTypes;
    }
    interface AthAvatar {
        /**
          * The aria-labelledby attribute of the icon
         */
        "ariaLabelledby"?: string;
        /**
          * Name used to generate initials if none are provided.
         */
        "avatarName"?: string;
        /**
          * Initials to display in the avatar.
         */
        "initials"?: string;
        /**
          * Size of the avatar.
          * @default AvatarSizes.Medium
         */
        "size"?: AvatarSize;
        /**
          * Type of avatar (image or initials).
         */
        "type"?: AvatarType;
    }
    interface AthBadge {
        /**
          * Badge color accompanying the purpose of the message
          * @default BADGE_DEFAULT_COLOR
         */
        "color"?: BadgeColorTypes;
        /**
          * Custom horizontal distance of the badge from its default position
          * @default 0
         */
        "distanceX"?: number;
        /**
          * Custom vertical distance of the badge from its default position
          * @default 0
         */
        "distanceY"?: number;
        /**
          * Accessibility label describing the message
         */
        "label"?: any;
        /**
          * Value from which a + will be added once exceeded by the "value"
          * @default MAX_VALUE
         */
        "max"?: number;
        /**
          * Positioning of the badge relative to the slot
         */
        "position"?: BadgePositions;
        /**
          * The badge can display a value or be a decorative element
          * @default BADGE_DEFAULT_TYPE
         */
        "type"?: BadgeTypes;
        /**
          * Value displayed within the badge if it is "numeric"
          * @default 0
         */
        "value"?: number;
    }
    interface AthBreadcrumb {
        /**
          * Definición de un aria-label personalizado para el breadcrumb
         */
        "athAriaLabel"?: string;
        /**
          * Si es true y el breadcrumb tiene más de 4 elementos, el breadcrumb se renderiza colapsado.  Al hacer click en "..." este valor se alterna.
          * @default false
         */
        "collapsed"?: boolean;
        /**
          * Lista de enlaces del breadcrumb. Normalmente se recibe como un string JSON desde HTML.
         */
        "options"?: any;
        /**
          * Separador entre los enlaces del breadcrumb
          * @default '/'
         */
        "separator"?: string;
    }
    interface AthButton {
        /**
          * The clear of the button (background and border color)
          * @default false
         */
        "clear"?: boolean;
        /**
          * The color variant of the button
          * @default ButtonColor.Primary
         */
        "color"?: ButtonColors;
        /**
          * The button is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The button can be adapted to its container width
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * The code of the button's icon (used with iconPosition)
         */
        "icon"?: string;
        /**
          * Whether the button has an icon and his position
          * @default ButtonIconPosition.None
         */
        "iconPosition"?: ButtonIconPositions;
        /**
          * Emitted when the button loses focus
         */
        "onAthBlur"?: (event: AthButtonCustomEvent<void>) => void;
        /**
          * Emitted when the button is clicked
         */
        "onAthClick"?: (event: AthButtonCustomEvent<void>) => void;
        /**
          * Emitted when the button gains focus
         */
        "onAthFocus"?: (event: AthButtonCustomEvent<void>) => void;
        /**
          * The size of the buton
          * @default ButtonSize.Medium
         */
        "size"?: ButtonSizes;
        /**
          * The type of the button
          * @default ButtonType.Button
         */
        "type"?: ButtonTypes;
    }
    interface AthButtonExpandable {
        "collapseTarget"?: string;
        /**
          * The button is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The code of the button's icon (used with iconPosition)
         */
        "icon"?: string;
        "onAthToggleCollapse"?: (event: AthButtonExpandableCustomEvent<string>) => void;
        /**
          * The size of the buton
          * @default ButtonExpandableSizesTypes.Large
         */
        "size"?: ButtonExpandableSizesType;
    }
    interface AthButtonLink {
        /**
          * The color variant of the button-link
          * @default ButtonLinkColor.Primary
         */
        "color"?: ButtonLinkColors;
        /**
          * The button-link is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The code of the button-link's icon
         */
        "icon"?: string;
        /**
          * Icon Position
          * @default ButtonLinkPosition.Left
         */
        "iconPosition"?: ButtonLinkPositions;
        /**
          * Emitted when the button-link loses focus
         */
        "onAthBlur"?: (event: AthButtonLinkCustomEvent<void>) => void;
        /**
          * Emitted when the button-link is clicked
         */
        "onAthClick"?: (event: AthButtonLinkCustomEvent<void>) => void;
        /**
          * Emitted when the button-link gains focus
         */
        "onAthFocus"?: (event: AthButtonLinkCustomEvent<void>) => void;
        /**
          * The size of the buton-link
          * @default ButtonLinkSize.Medium
         */
        "size"?: ButtonLinkSizes;
    }
    interface AthCalendar {
        /**
          * The color of the Calendar.
          * @default CalendarColors.Primary
         */
        "color"?: CalendarColor;
        /**
          * List of days which are shown as disabled.
         */
        "disabledDates"?: string;
        /**
          * List of days which are shown as highlighted.
         */
        "highlightedDates"?: string;
        /**
          * If true, all the weekends will be highlighted.
          * @default false
         */
        "highlightedWeekends"?: boolean;
        /**
          * The maximum date that can be selected.
         */
        "max"?: string;
        /**
          * The minimum date that can be selected.
         */
        "min"?: string;
        /**
          * Emitted when the value has changed. This event doesn't fire until the control loses focus.
         */
        "onAthChange"?: (event: AthCalendarCustomEvent<string>) => void;
        "selected"?: string;
        /**
          * The type of the Calendar.
          * @default CalendarTypes.Date
         */
        "type"?: CalendarType;
    }
    interface AthCard {
        /**
          * ancho máximo de la card
         */
        "ariaLabelledBy"?: string;
        /**
          * Card is clickable
          * @default false
         */
        "clickable"?: boolean;
        /**
          * if Card thumbnail is fluid
          * @default false
         */
        "fluid"?: boolean;
        /**
          * ancho máximo de la card
         */
        "maxWidth"?: string;
        /**
          * Emitted when card loses focus
         */
        "onAthBlur"?: (event: AthCardCustomEvent<void>) => void;
        /**
          * Emitted when card is clicked
         */
        "onAthClick"?: (event: AthCardCustomEvent<void>) => void;
        /**
          * Emitted when card gains focus
         */
        "onAthFocus"?: (event: AthCardCustomEvent<void>) => void;
        /**
          * Orientation Card
          * @default CardOrientation.Vertical
         */
        "orientation"?: CardOrientations;
        /**
          * Size of the card
          * @default CardSize.Small
         */
        "size"?: CardSizes;
        /**
          * ancho de la card
         */
        "width"?: string;
    }
    interface AthCardHeader {
        /**
          * date of the card header
         */
        "date"?: string;
        /**
          * Title of the card header
         */
        "headingText"?: string;
        /**
          * Overline of the card header
         */
        "overline"?: string;
        /**
          * Subtitle of the card
         */
        "subtitle"?: string;
    }
    interface AthCardSelectable {
        /**
          * Indicates whether the card is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * headline of the card
         */
        "headingText"?: string;
        "onAthBlur"?: (event: AthCardSelectableCustomEvent<void>) => void;
        "onAthChange"?: (event: AthCardSelectableCustomEvent<any>) => void;
        "onAthFocus"?: (event: AthCardSelectableCustomEvent<void>) => void;
        /**
          * overline of the card
         */
        "overline"?: string;
        /**
          * Indicates whether the card is selected
          * @default false
         */
        "selected"?: boolean;
        /**
          * Size of the card
          * @default CardSelectableSize.Small
         */
        "size"?: CardSelectableSizes;
        /**
          * subtitle of the card
         */
        "subtitle"?: string;
        /**
          * tag of the card
         */
        "tag"?: string;
        /**
          * type of card
          * @default CardSelectableType.Single
         */
        "type"?: CardSelectableTypes;
    }
    interface AthCardSelectableGroup {
        /**
          * Indicates whether the card selectable group is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Indicates whether the group is multi selection
          * @default false
         */
        "multiple"?: boolean;
        "onAthValueChanged"?: (event: AthCardSelectableGroupCustomEvent<HTMLAthCardSelectableElement[]>) => void;
        /**
          * Size for the cards
          * @default CardSelectableGroupSize.Small
         */
        "size"?: CardSelectableGroupSizes;
    }
    interface AthCardThumbnail {
        /**
          * Text for bottom tag
         */
        "bottomTag"?: string;
        /**
          * text highlight
         */
        "highlightText"?: string;
        /**
          * Text for top tag
         */
        "topTag"?: string;
        /**
          * type of thumnail
          * @default ThumbnailType.Default
         */
        "type"?: ThumbnailTypes;
    }
    interface AthCheckbox {
        /**
          * Accessible text when there is no visible label
         */
        "ariaLabel"?: string | null;
        /**
          * If the element is focused
          * @default false
         */
        "autofocus"?: boolean;
        /**
          * If the checkbox is checked by default
          * @default false
         */
        "checked"?: boolean;
        /**
          * If it is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Type of feedback
          * @default FeedbackType.None
         */
        "feedback"?: FeedbackTypes;
        /**
          * Text of the feedback
         */
        "feedbackText"?: string;
        /**
          * Text below the checkbox (helper text)
         */
        "helperText"?: string;
        /**
          * If the required character is shown in the label
          * @default false
         */
        "hideRequired"?: boolean;
        /**
          * If the checkbox is indeterminate by default
          * @default false
         */
        "indeterminate"?: boolean;
        /**
          * Label of the checkbox
         */
        "label"?: string;
        /**
          * Name of the checkbox (necessary for forms)
         */
        "name"?: string;
        /**
          * Emitted when the checkbox loses focus
         */
        "onAthBlur"?: (event: AthCheckboxCustomEvent<void>) => void;
        /**
          * Emitted when the checkbox change
         */
        "onAthChange"?: (event: AthCheckboxCustomEvent<CheckboxChangeEventDetail>) => void;
        /**
          * Emitted when the checkbox gains focus
         */
        "onAthFocus"?: (event: AthCheckboxCustomEvent<void>) => void;
        /**
          * If it is read-only
          * @default false
         */
        "readonly"?: boolean;
        /**
          * If it is required
          * @default false
         */
        "required"?: boolean;
        /**
          * Value of the checkbox
          * @default CheckboxValue.False
         */
        "value"?: CheckboxValues;
    }
    interface AthCheckboxGroup {
        /**
          * Indica si esta deshabilitado
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Indica el tipo de feedback
          * @default FeedbackType.None
         */
        "feedback"?: FeedbackTypes1;
        /**
          * Texto feedback
         */
        "feedbackText"?: string;
        /**
          * Texto ayuda
         */
        "helperText"?: string;
        /**
          * Texto para el Label
         */
        "label"?: string;
        /**
          * Atributo name a aplicar a todo el grupo
         */
        "name"?: string;
        /**
          * Emite el array de checkboxes seleccionados
         */
        "onAthChecked"?: (event: AthCheckboxGroupCustomEvent<CheckboxChangeEventDetail[]>) => void;
        /**
          * Indica si es solo lectura
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Texto oculto para lectores de pantalla indicando que el grupo es requerido
         */
        "requiredAriaLabel"?: string;
        /**
          * Indica si se muestra el asterisco
          * @default false
         */
        "showRequired"?: boolean;
        /**
          * Indica el texto del tooltip
         */
        "tooltipText"?: string;
        /**
          * Indica el ancho de la burbuja tooltip
          * @default 0
         */
        "tooltipWidth"?: number;
    }
    interface AthChipChoice {
        /**
          * Indica si el chip esta deshabilitado
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Indica el nombre del icono a usar
         */
        "icon"?: string;
        /**
          * Texto del chip
         */
        "label"?: string;
        /**
          * The chip name for HTML Form API
         */
        "name"?: string;
        "onAthBlur"?: (event: AthChipChoiceCustomEvent<void>) => void;
        "onAthChange"?: (event: AthChipChoiceCustomEvent<any>) => void;
        "onAthFocus"?: (event: AthChipChoiceCustomEvent<void>) => void;
        /**
          * The role of the chip
          * @default ChipChoiceRole.Checkbox
         */
        "role"?: string | null;
        /**
          * Indica si el chip esta seleccionado
          * @default false
         */
        "selected"?: boolean;
        /**
          * Indica el tamaño del chip (sm/md)
          * @default ChipChoiceSize.Medium
         */
        "size"?: ChipChoiceSizes;
        /**
          * The chip value for HTML Form API
         */
        "value"?: string;
    }
    interface AthChipChoiceGroup {
        /**
          * Weather the chips are disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Allow multiple selection of chips
          * @default false
         */
        "multiple"?: boolean;
        /**
          * The generic name for the chips
         */
        "name"?: string;
        /**
          * Event to emit the current chips checked
         */
        "onAthChangeValue"?: (event: AthChipChoiceGroupCustomEvent<HTMLAthChipChoiceElement[]>) => void;
        /**
          * The generic size of the chips
          * @default ChipChoiceSize.Medium
         */
        "size"?: ChipChoiceSizes;
        /**
          * The value for not multiple (use chip-choice-group as radio-group)
         */
        "value"?: string;
        /**
          * The width of the group
         */
        "width"?: string;
    }
    interface AthChipDismiss {
        /**
          * The button is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The text in the chip
         */
        "headingText"?: string;
        /**
          * The icon to the left
         */
        "icon"?: string;
        /**
          * The accesible label-dismiss attribute in chip dismiss
          * @default 'Eliminar'
         */
        "labelDismiss"?: string;
        /**
          * Emitted when the x icon is clicked
         */
        "onAthDismiss"?: (event: AthChipDismissCustomEvent<void>) => void;
        /**
          * The size of the chip dismiss
          * @default ChipDismissSize.Medium
         */
        "size"?: ChipDismissSizes;
    }
    interface AthChipDismissGroup {
        /**
          * Weather the chips are disabled
         */
        "disabled"?: boolean;
        /**
          * The generic size of the chips
          * @default ChipDismissSize.Medium
         */
        "size"?: ChipDismissSizes;
        /**
          * The width of the group
         */
        "width"?: string;
    }
    interface AthCollapse {
        /**
          * Event to emit if the component is expanded or collapsed.
         */
        "onAthCollapseState"?: (event: AthCollapseCustomEvent<{ id: string; isExpanded: boolean }>) => void;
        /**
          * If the component is expanded by default
          * @default false
         */
        "show"?: boolean;
    }
    interface AthCollapseIcon {
        /**
          * Current expanded state
          * @default false
         */
        "expanded"?: boolean;
    }
    interface AthDatepicker {
        /**
          * Whether the datepicker is focused on page load.
         */
        "autofocus"?: boolean;
        /**
          * The color of the datepicker.
          * @default DatepickerColors.Primary
         */
        "color"?: DatepickerColor;
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * List of days which are shown as disabled.
         */
        "disabledDates"?: string;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown
          * @default DatepickerFeedbacks.None
         */
        "feedback"?: DatepickerFeedback;
        /**
          * The feedback message.
         */
        "feedbackText"?: string;
        /**
          * Date format to be used in the datepicker. Only used when the type is 'date'.
          * @default 'DD/MM/YYYY'
         */
        "format"?: string;
        /**
          * Message to help the user fills the datepicker.
         */
        "helperText"?: string;
        /**
          * If true, the * asterisk will be show when required = true.
          * @default false
         */
        "hideRequired"?: boolean;
        /**
          * List of days which are shown as highlighted.
         */
        "highlightedDates"?: string;
        /**
          * If true, all the weekends will be highlighted.
          * @default false
         */
        "highlightedWeekends"?: boolean;
        /**
          * The aria-label attribute of the input
         */
        "inputAriaLabel"?: string;
        /**
          * Caption of the datepicker
         */
        "label"?: string;
        /**
          * The maximum date that can be selected.
         */
        "max"?: string;
        /**
          * The minimum date that can be selected.
         */
        "min"?: string;
        /**
          * The name of the datepicker. Submitted with the form as part of a name/value pair
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus
         */
        "onAthBlur"?: (event: AthDatepickerCustomEvent<void>) => void;
        /**
          * Emitted when the value has changed. This event doesn't fire until the control loses focus.
         */
        "onAthChange"?: (event: AthDatepickerCustomEvent<string>) => void;
        /**
          * Emitted when the input gains focus
         */
        "onAthFocus"?: (event: AthDatepickerCustomEvent<void>) => void;
        /**
          * Emitted every time the value is updated by introducing a change
         */
        "onAthInput"?: (event: AthDatepickerCustomEvent<string>) => void;
        "placeholder"?: string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly"?: boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required"?: boolean;
        /**
          * The size of the datepicker.
          * @default DatepickerSizes.Medium
         */
        "size"?: DatepickerSize;
        /**
          * If true, submit the form when pressing Enter in the input field and the input is inside a form
          * @default false
         */
        "submitOnEnter"?: boolean;
        /**
          * Text to be shown in the tooltip
         */
        "tooltipText"?: string;
        /**
          * The type of the datepicker.
          * @default DatepickerTypes.Date
         */
        "type"?: DatepickerType;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value"?: string;
    }
    interface AthDatepickerRange {
        /**
          * Whether the datepicker is focused on page load.
         */
        "autofocus"?: boolean;
        /**
          * The color of the datepicker-range.
          * @default DatepickerRangeColors.Primary
         */
        "color"?: DatepickerRangeColor;
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * List of days which are shown as disabled.
         */
        "disabledDates"?: string;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown
          * @default DatepickerRangeFeedbacks.None
         */
        "feedback"?: DatepickerRangeFeedback;
        /**
          * The feedback message.
         */
        "feedbackText"?: string;
        /**
          * Date format to be used in the datepicker-range. Only used when the type is 'date'.
          * @default 'DD/MM/YYYY'
         */
        "format"?: string;
        /**
          * Message to help the user fills the datepicker-range.
         */
        "helperText"?: string;
        /**
          * If true, the side panel will be hidden.
          * @default false
         */
        "hidePanel"?: boolean;
        /**
          * If true, the * asterisk will be show when required = true.
          * @default false
         */
        "hideRequired"?: boolean;
        /**
          * List of days which are shown as highlighted.
         */
        "highlightedDates"?: string;
        /**
          * If true, all the weekends will be highlighted.
          * @default false
         */
        "highlightedWeekends"?: boolean;
        /**
          * The aria-label attribute of the end input
         */
        "inputAriaLabelEnd"?: string;
        /**
          * The aria-label attribute of the start input
         */
        "inputAriaLabelStart"?: string;
        /**
          * Caption of the datepicker-range
         */
        "label"?: string;
        /**
          * Caption of the datepicker-range
         */
        "labelEnd"?: string;
        /**
          * Caption of the range start of the datepicker-range
         */
        "labelStart"?: string;
        /**
          * The maximum date that can be selected.
         */
        "max"?: string;
        /**
          * The minimum date that can be selected.
         */
        "min"?: string;
        /**
          * The name of the datepicker-range. Submitted with the form as part of a name/value pair
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus
         */
        "onAthBlur"?: (event: AthDatepickerRangeCustomEvent<void>) => void;
        /**
          * Emitted when the value has changed. This event doesn't fire until the control loses focus.
         */
        "onAthChange"?: (event: AthDatepickerRangeCustomEvent<string>) => void;
        /**
          * Emitted when the input gains focus
         */
        "onAthFocus"?: (event: AthDatepickerRangeCustomEvent<void>) => void;
        "placeholderEnd"?: string;
        "placeholderStart"?: string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly"?: boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required"?: boolean;
        /**
          * If true, the user must fill in a value of end range before submitting a form.
          * @default false
         */
        "requiredEnd"?: boolean;
        /**
          * If true, the user must fill in a value of start range before submitting a form.
          * @default false
         */
        "requiredStart"?: boolean;
        /**
          * The size of the datepicker-range.
          * @default DatepickerRangeSizes.Medium
         */
        "size"?: DatepickerRangeSize;
        /**
          * If true, submit the form when pressing Enter in the input field and the input is inside a form
          * @default false
         */
        "submitOnEnter"?: boolean;
        /**
          * Text to be shown in the tooltip
         */
        "tooltipText"?: string;
        /**
          * The type of the datepicker-range.
          * @default DatepickerRangeTypes.Date
         */
        "type"?: DatepickerRangeType;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value"?: string;
    }
    interface AthDivider {
        /**
          * Color of the divider
          * @default DIVIDER_DEFAULT_COLOR
         */
        "color"?: DividerColorType;
        /**
          * Orientation of the divider
          * @default DIVIDER_DEFAULT_ORIENTATION
         */
        "orientation"?: DividerOrientationType;
        /**
          * Size of the divider
          * @default DIVIDER_DEFAULT_SIZE
         */
        "size"?: DividerSizeType;
    }
    interface AthDropdown {
        /**
          * Text to announce the items found in search input
          * @default 'Hay [total] elementos en la lista'
         */
        "announceResultText"?: string;
        /**
          * Si dropdown esta deshabilitado
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Nombre accesible para el dropdown
         */
        "dropdownAriaLabel"?: string;
        /**
          * Tipo feedback
          * @default dropdownFeedbackType.None
         */
        "feedback"?: dropdownFeedbackTypes;
        /**
          * Texto feedback
         */
        "feedbackText"?: string;
        /**
          * Texto de ayuda
         */
        "helperText"?: string;
        /**
          * If true, Do no show required mark for required input
          * @default false
         */
        "hideRequired"?: boolean;
        /**
          * Label dropdown
         */
        "label"?: string;
        /**
          * Si dropdown es multiseleccion
          * @default false
         */
        "multiselect"?: boolean;
        /**
          * The name of the combobox. Submitted with the form as part of a name/value pair
         */
        "name"?: string;
        /**
          * texto cuando multiselect es true, showChips es false y se selecciona una opcion
         */
        "nochipsText"?: string;
        /**
          * no result text
         */
        "noresultText"?: string;
        /**
          * Emitted when the combobox loses focus
         */
        "onAthBlur"?: (event: AthDropdownCustomEvent<void>) => void;
        /**
          * Emitted when option changed
         */
        "onAthChange"?: (event: AthDropdownCustomEvent<ActionListItem[]>) => void;
        /**
          * Emitted when the combobox gains focus
         */
        "onAthFocus"?: (event: AthDropdownCustomEvent<void>) => void;
        /**
          * Si dropdown esta abierto
          * @default false
         */
        "open"?: boolean;
        /**
          * Altura del overlay del dropdown
         */
        "overlayMaxHeight"?: string;
        /**
          * Placeholder
         */
        "placeholder"?: string;
        /**
          * Si dropdown es solo lectura
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Si dropdown es obligatorio
          * @default false
         */
        "required"?: boolean;
        /**
          * Si dropdown tiene bloque de busqueda
          * @default false
         */
        "search"?: boolean;
        /**
          * Texto placeholder del bloque de busqueda
          * @default 'Buscar'
         */
        "searchAriaLabel"?: string;
        /**
          * Texto placeholder del bloque de busqueda
          * @default ''
         */
        "searchPlaceholder"?: string;
        /**
          * Mostrar chips
          * @default false
         */
        "showChips"?: boolean;
        /**
          * Tamaño dropdown
          * @default dropdownSize.Md
         */
        "size"?: dropdownSizes;
        /**
          * Texto del tooltip
         */
        "tooltipText"?: string;
        /**
          * Ancho del tooltip
          * @default 0
         */
        "tooltipWidth"?: number;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair
         */
        "value"?: string;
        /**
          * Ancho dropdown
         */
        "width"?: string;
    }
    interface AthDropdownOption {
        /**
          * Si esta deshabilitado
          * @default false
         */
        "disabled"?: boolean;
        /**
          * icono para opcion
         */
        "icon"?: string;
        /**
          * name option
         */
        "name"?: string;
        "onOptSelected"?: (event: AthDropdownOptionCustomEvent<{ source: 'user' | 'programmatic' }>) => void;
        /**
          * Permite agrupaciones
         */
        "optionGroup"?: boolean;
        /**
          * Si esta selecionado
          * @default false
         */
        "selected"?: boolean;
        /**
          * etiqueta accesible para la opcionseleccionada
          * @default 'seleccionada'
         */
        "selectedAriaLabel"?: string;
        /**
          * texto del option
         */
        "text"?: string;
        /**
          * Valor del option
         */
        "value"?: string;
    }
    interface AthEmptyState {
        /**
          * Text to empty state description.
         */
        "description"?: string;
        /**
          * Indicates the heading level for the empty state.
          * @default 4
         */
        "headingLevel"?: number;
        /**
          * Indicates the heading size for the heading text.
          * @default HeadingSize.Sm
         */
        "headingSize"?: HeadingSizes;
        /**
          * Text to empty state heading
         */
        "headingText"?: string;
        /**
          * Indicates if the image will be hidden Does not apply when type is 'loading'
          * @default false
         */
        "hideImage"?: boolean;
        /**
          * Accesibility label for loading state (only when type is 'loading')
         */
        "loadingLabel"?: string;
        /**
          * Indicates the type of empty state
          * @default EmptyStateType.Empty
         */
        "type"?: EmptyStateTypes;
    }
    interface AthIcon {
        /**
          * The aria-label attribute of the icon
         */
        "ariaLabel"?: string | null;
        /**
          * The aria-labelledby attribute of the icon
         */
        "ariaLabelledby"?: string;
        /**
          * Color del icon
         */
        "color"?: IconColorTypes;
        /**
          * The icon name
         */
        "icon"?: string;
        /**
          * The size of the icon
          * @default IconSize.Medium
         */
        "size"?: IconSizeTypes;
    }
    interface AthInputCounter {
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown.
          * @default InputCounterFeedbackTypes.None
         */
        "feedback"?: InputCounterFeedbackType;
        /**
          * The message for the feedback.
         */
        "feedbackText"?: string;
        /**
          * Message to help the user fill the input value.
         */
        "helperText"?: string;
        /**
          * If true, the controls are not visible.
          * @default false
         */
        "hideControls"?: boolean;
        /**
          * If true, the * asterisk will be hidden when the input is required.
          * @default false
         */
        "hideRequired"?: boolean;
        /**
          * The aria-label attribute of the input.
         */
        "inputAriaLabel"?: string;
        /**
          * Represents the caption of the input.
         */
        "label"?: string;
        /**
          * Represents the maximum number of the input.
         */
        "max"?: number;
        /**
          * Represents the minimum number of the input.
         */
        "min"?: number;
        /**
          * The name of the input. Submitted with the form as part of a name/value pair.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onAthBlur"?: (event: AthInputCounterCustomEvent<void>) => void;
        /**
          * Emitted when the value has changed. This event doesn't fire until the control loses focus.
         */
        "onAthChange"?: (event: AthInputCounterCustomEvent<string>) => void;
        /**
          * Emitted when the input gains focus.
         */
        "onAthFocus"?: (event: AthInputCounterCustomEvent<void>) => void;
        /**
          * Emitted every time the value is updated by introducing a change.
         */
        "onAthInput"?: (event: AthInputCounterCustomEvent<string>) => void;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly"?: boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required"?: boolean;
        /**
          * Specifies the size of the input.
          * @default InputCounterSizes.Medium
         */
        "size"?: InputCounterSize;
        /**
          * Specifies the interval between legal numbers in an <input> element.
          * @default 1
         */
        "step"?: number;
        /**
          * Specifies text for tooltip.
         */
        "tooltipText"?: string;
        /**
          * Specifies width for tooltip.
         */
        "tooltipWidth"?: number;
        /**
          * Specifies the unit for the input.
         */
        "unit"?: string;
        /**
          * Specifies the accesible unit for the input.
         */
        "unitAriaLabel"?: string;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value"?: string;
    }
    interface AthInputPassword {
        /**
          * Whether the input will be autocompleted.
         */
        "autocomplete"?: InputPasswordAutocomplete;
        /**
          * Whether the input is focused on page load.
         */
        "autofocus"?: boolean;
        /**
          * Shows a counter
         */
        "counter"?: boolean;
        /**
          * SThe label of the counter
          * @default '[length] de [max] caracteres. Quedan [rest]'
         */
        "counterLabel"?: string;
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown
          * @default InputFeedbackTypes.None
         */
        "feedback"?: "error" | "success" | "warning" | "none";
        /**
          * The message for the feedback.
          * @default InputFeedbackTypes.Error
         */
        "feedbackText"?: "error" | "success" | "warning" | "none";
        /**
          * Message to help the user fills the input value
         */
        "helperText"?: string;
        /**
          * If true, the * asterisk will be show when required = true.
          * @default false
         */
        "hideRequired"?: boolean;
        /**
          * The aria-label attribute of the input
         */
        "inputAriaLabel"?: string;
        /**
          * Set tabindex
          * @default '0'
         */
        "inputTabindex"?: string;
        /**
          * Represents the caption of the input
         */
        "label"?: string;
        /**
          * The accesible text to button Hide Password
          * @default 'Ocultar password'
         */
        "labelHidePassword"?: string;
        /**
          * The accesible text to button Show Password
          * @default 'Ver password'
         */
        "labelShowPassword"?: string;
        /**
          * Specifies the maximum number of characters allowed in the input element
         */
        "maxlength"?: number;
        /**
          * The name of the input. Submitted with the form as part of a name/value pair
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus
         */
        "onAthBlur"?: (event: AthInputPasswordCustomEvent<void>) => void;
        /**
          * Emitted when the value has changed. This event doesn't fire until the control loses focus.
         */
        "onAthChange"?: (event: AthInputPasswordCustomEvent<string>) => void;
        /**
          * Emitted when the component is cleared
         */
        "onAthClear"?: (event: AthInputPasswordCustomEvent<string>) => void;
        /**
          * Emitted when the input gains focus
         */
        "onAthFocus"?: (event: AthInputPasswordCustomEvent<void>) => void;
        /**
          * Emitted every time the value is updated by introducing a change
         */
        "onAthInput"?: (event: AthInputPasswordCustomEvent<string>) => void;
        /**
          * Specifies a regular expression that the input element's value is checked
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly"?: boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required"?: boolean;
        /**
          * The size of the input
          * @default InputSizes.Medium
         */
        "size"?: "lg" | "md" | "sm";
        /**
          * If true, submit the form when pressing Enter in the input field and the input is inside a form
          * @default false
         */
        "submitOnEnter"?: boolean;
        /**
          * The text to be shown in the tooltip
         */
        "tooltipText"?: string;
        /**
          * The max width to the text in the tooltip
         */
        "tooltipWidth"?: any;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value"?: string;
    }
    interface AthInputText {
        /**
          * Whether the input will be autocompleted.
         */
        "autocomplete"?: string;
        /**
          * Whether the input is focused on page load.
         */
        "autofocus"?: boolean;
        /**
          * The label and aria-label of the clear button
          * @default 'Borrar'
         */
        "clearButtonAriaLabel"?: string;
        /**
          * Shows a counter
         */
        "counter"?: boolean;
        /**
          * SThe label of the counter
          * @default '[length] de [max] caracteres. Quedan [rest]'
         */
        "counterLabel"?: string;
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown
          * @default InputFeedbackTypes.None
         */
        "feedback"?: "error" | "none";
        /**
          * The feedback message.
         */
        "feedbackText"?: string;
        /**
          * Include a button to clear the value
          * @default false
         */
        "hasClear"?: boolean;
        /**
          * Message to help the user fills the input value
         */
        "helperText"?: string;
        /**
          * If true, the * asterisk will be hidden when required = true.
          * @default false
         */
        "hideRequired"?: boolean;
        /**
          * The icon name for the input's icon
         */
        "icon"?: string;
        /**
          * The icon position
          * @default InputIconPositions.Left
         */
        "iconPosition"?: "left" | "right";
        /**
          * The aria-label attribute of the input
         */
        "inputAriaLabel"?: string;
        /**
          * Set tabindex
          * @default '0'
         */
        "inputTabindex"?: string;
        /**
          * Represents the caption of the input
         */
        "label"?: string;
        /**
          * Specifies the maximum number of characters allowed in the input element
         */
        "maxlength"?: number;
        /**
          * The name of the input. Submitted with the form as part of a name/value pair
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus
         */
        "onAthBlur"?: (event: AthInputTextCustomEvent<void>) => void;
        /**
          * Emitted when the value has changed. This event doesn't fire until the control loses focus.
         */
        "onAthChange"?: (event: AthInputTextCustomEvent<string>) => void;
        /**
          * Emitted when the component is cleared
         */
        "onAthClear"?: (event: AthInputTextCustomEvent<string>) => void;
        /**
          * Emitted when the input gains focus
         */
        "onAthFocus"?: (event: AthInputTextCustomEvent<void>) => void;
        /**
          * Emitted every time the value is updated by introducing a change
         */
        "onAthInput"?: (event: AthInputTextCustomEvent<string>) => void;
        /**
          * Specifies a regular expression that the input element's value is checked
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly"?: boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required"?: boolean;
        /**
          * The size of the input
          * @default InputSizes.Medium
         */
        "size"?: InputSize;
        /**
          * If true, submit the form when pressing Enter in the input field and the input is inside a form
          * @default false
         */
        "submitOnEnter"?: boolean;
        /**
          * The text to be shown in the tooltip
         */
        "tooltipText"?: string;
        /**
          * The max width to the text in the tooltip
         */
        "tooltipWidth"?: any;
        /**
          * The type of the input
          * @default InputTextTypes.Text
         */
        "type"?: "search" | "text" | "url" | "email" | "tel";
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value"?: string;
    }
    interface AthInputTextarea {
        /**
          * Whether the input will be autocompleted.
         */
        "autocomplete"?: string;
        /**
          * Whether the input is focused on page load.
         */
        "autofocus"?: boolean;
        /**
          * Shows a counter
         */
        "counter"?: boolean;
        /**
          * SThe label of the counter
          * @default '[length] de [max] caracteres. Quedan [rest]'
         */
        "counterLabel"?: string;
        /**
          * If true, the user cannot interact with the input.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown
          * @default InputFeedbackTypes.None
         */
        "feedback"?: "error" | "none";
        /**
          * The feedback message.
         */
        "feedbackText"?: string;
        /**
          * Message to help the user fills the input value
         */
        "helperText"?: string;
        /**
          * If true, the * asterisk will be hidden when required = true.
          * @default false
         */
        "hideRequired"?: boolean;
        /**
          * The aria-label attribute of the input
         */
        "inputAriaLabel"?: string;
        /**
          * Set tabindex
          * @default '0'
         */
        "inputTabindex"?: string;
        /**
          * Represents the caption of the input
         */
        "label"?: string;
        /**
          * Specifies the maximum number of characters allowed in the input element
         */
        "maxlength"?: number;
        /**
          * The name of the input. Submitted with the form as part of a name/value pair
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus
         */
        "onAthBlur"?: (event: AthInputTextareaCustomEvent<void>) => void;
        /**
          * Emitted when the value has changed. This event doesn't fire until the control loses focus.
         */
        "onAthChange"?: (event: AthInputTextareaCustomEvent<string>) => void;
        /**
          * Emitted when the input gains focus
         */
        "onAthFocus"?: (event: AthInputTextareaCustomEvent<void>) => void;
        /**
          * Emitted every time the value is updated by introducing a change
         */
        "onAthInput"?: (event: AthInputTextareaCustomEvent<string>) => void;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly"?: boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required"?: boolean;
        /**
          * Number of visible rows.
         */
        "rows"?: number;
        /**
          * The size of the input
          * @default InputSizes.Medium
         */
        "size"?: InputSize1;
        /**
          * The text to be shown in the tooltip
         */
        "tooltipText"?: string;
        /**
          * The max width to the text in the tooltip
          * @default 0
         */
        "tooltipWidth"?: number;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
         */
        "value"?: string;
        /**
          * The max width to the text in the tooltip
         */
        "width"?: string;
    }
    interface AthLink {
        /**
          * aria-describedby para link
         */
        "ariaDescribedby"?: string;
        /**
          * aria-label para link
         */
        "ariaLabel"?: string | null;
        /**
          * aria-labelledby para link
         */
        "ariaLabelledby"?: string | null;
        /**
          * Indica si el link esta deshabilitado
         */
        "disabled"?: boolean;
        /**
          * Additional text to be appended to the aria-label to indicate that this is an external link
         */
        "externalLabel"?: string;
        /**
          * Indica el icono a usar
         */
        "icon"?: string;
        /**
          * Indica el aria-label para icono
         */
        "iconAriaLabel"?: string;
        /**
          * Url del destino
         */
        "linkHref"?: string;
        /**
          * Target para indicar donde se abrira
          * @default linkTarget.Blank
         */
        "linkTarget"?: linkTargets;
        /**
          * Emitted when the link loses focus
         */
        "onAthBlur"?: (event: AthLinkCustomEvent<void>) => void;
        /**
          * Emitted when the link is clicked
         */
        "onAthClick"?: (event: AthLinkCustomEvent<void>) => void;
        /**
          * Emitted when the lin gains focus
         */
        "onAthFocus"?: (event: AthLinkCustomEvent<void>) => void;
        /**
          * Tamaño link
          * @default linkSize.Md
         */
        "size"?: linkSizes;
        /**
          * Opcion del subrayado
          * @default true
         */
        "underline"?: boolean;
    }
    interface AthList {
        /**
          * List is clickable
          * @default false
         */
        "clickable"?: boolean;
        /**
          * List state disabled, only works if clickable is true
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Define if the list contains dividers between items
         */
        "hasDivider"?: boolean;
        /**
          * Define the list orientation
          * @default ListOrientation.Vertical
         */
        "orientation"?: ListOrientationType;
        /**
          * List spacings size
          * @default ListSizes.Medium
         */
        "size"?: ListSizeType;
    }
    interface AthListItem {
        /**
          * The aria-label attribute of the clicable item
         */
        "athAriaLabel"?: string | null;
        /**
          * ListItem is clickable
          * @default false
         */
        "clickable"?: boolean;
        /**
          * List item description
         */
        "description"?: string;
        /**
          * List item state disabled, only works if clickable is true
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Additional text to be appended to the aria-label to indicate that this is an external link
          * @default 'Se abre una ventana nueva'
         */
        "externalLabel"?: string;
        /**
          * List item divider. If user doesn't inform it, its informed from parent list
         */
        "hasDivider"?: boolean;
        /**
          * Heading level for the title
          * @default 4
         */
        "headingLevel"?: number;
        /**
          * List item title
         */
        "headingText"?: string;
        /**
          * URL when clickable is true
         */
        "href"?: string;
        /**
          * Emitted when listItem is clicked
         */
        "onAthClick"?: (event: AthListItemCustomEvent<void>) => void;
        /**
          * List item orientation. Its informed from parent list
          * @default ListOrientation.Vertical
         */
        "orientation"?: ListOrientationType;
        /**
          * Type of rel to url
         */
        "rel"?: string;
        /**
          * List item size. Its informed from parent list
          * @default ListSizes.Medium
         */
        "size"?: ListSizeType;
        /**
          * List item subtitle
         */
        "subtitle"?: string;
        /**
          * Type of target to url
          * @default ListLinkTarget.Self
         */
        "target"?: ListLinkTargetType;
        /**
          * List item tooltip
         */
        "tooltip"?: string;
        /**
          * Tooltip max-width
          * @default 240
         */
        "tooltipMaxWidth"?: number;
    }
    interface AthMenuButton {
        /**
          * The overlay's position relative to the origin
          * @default Alignment.Left
         */
        "alignment"?: Alignments;
        /**
          * The accesible label of the menu-button
         */
        "athAriaLabel"?: string;
        /**
          * Weather the button is focused by default
         */
        "autofocus"?: boolean;
        /**
          * The clear of the button (background and border color)
         */
        "clear"?: boolean;
        /**
          * The color variant of the button
          * @default ButtonColor.Primary
         */
        "color"?: ButtonColors;
        /**
          * The button is disabled
         */
        "disabled"?: boolean;
        /**
          * The code of the button's icon (used with iconPosition)
          * @default 'placeholder'
         */
        "icon"?: string;
        /**
          * Emitted when an item is clicked
         */
        "onAthAction"?: (event: AthMenuButtonCustomEvent<{ item: HTMLAthMenuButtonItemElement }>) => void;
        /**
          * Wheather the menu is open by default
         */
        "open"?: boolean;
        /**
          * Altura del overlay del menu
         */
        "overlayMaxHeight"?: string;
        /**
          * The size of the button
          * @default ButtonSize.Medium
         */
        "size"?: ButtonSizes;
    }
    interface AthMenuButtonItem {
        /**
          * Weather the button is disabled
         */
        "disabled"?: boolean;
        /**
          * The name of the grout the item belongs to
         */
        "groupName"?: string;
        /**
          * The icon of the menu-button-item
         */
        "icon"?: string;
        /**
          * @default -1
         */
        "itemTabIndex"?: number;
        /**
          * name option
         */
        "name"?: string;
        /**
          * Emitted when the item is clicked and triggers an action
         */
        "onAthSelected"?: (event: AthMenuButtonItemCustomEvent<HTMLAthMenuButtonItemElement>) => void;
        /**
          * The text of the menu-button-item
         */
        "text"?: string;
    }
    interface AthMenuHorizontal {
        /**
          * The accessible label for the menu
         */
        "athAriaLabel"?: string;
        /**
          * Whether the menu has a divider below
          * @default true
         */
        "hasDivider"?: boolean;
        /**
          * Items to generate using the imperative way
         */
        "items"?: MenuHorizontalItem[] | string;
        /**
          * Emitted when an item is selected with the MenuHorizontalItem object
         */
        "onAthSelected"?: (event: AthMenuHorizontalCustomEvent<MenuHorizontalItem>) => void;
    }
    interface AthMenuHorizontalItem {
        /**
          * The accessible text of the badge
         */
        "badgeLabel"?: string;
        /**
          * The maximum value inside the badge
         */
        "badgeMax"?: number;
        /**
          * The value of the badge
          * @default undefined
         */
        "badgeValue"?: number;
        /**
          * Whether the item is disabled or not
         */
        "disabled"?: boolean;
        /**
          * Additional text to be appended to the aria-label to indicate that this is an external link
          * @default '(Se abre en una nueva ventana)'
         */
        "externalLabel"?: string;
        /**
          * The URL of the item
         */
        "href"?: string;
        /**
          * The label of the item
         */
        "label"?: string;
        /**
          * Specifies the relationship of the linked URL
         */
        "rel"?: string;
        /**
          * Whether the item is selected or not
         */
        "selected"?: boolean;
        /**
          * The target of the link
          * @default TargetType.Self
         */
        "target"?: TargetTypes;
        "value"?: any;
    }
    interface AthMenuLateral {
        /**
          * (JSON) Object of items to generate
         */
        "items"?: MenuLateralItem[] | string;
        /**
          * Events
         */
        "onAthSelected"?: (event: AthMenuLateralCustomEvent<{ item: HTMLAthMenuLateralItemActionElement | HTMLAthMenuLateralItemLinkElement }>) => void;
    }
    interface AthMenuLateralItemAction {
        /**
          * The aria-label of the item
         */
        "ariaLabel"?: string | null;
        /**
          * The accesible label of the badge
         */
        "badgeLabel"?: string;
        /**
          * The maximum value inside the badge
         */
        "badgeMax"?: number;
        /**
          * The value inside the badge
         */
        "badgeValue"?: number;
        /**
          * Weather the button is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The icon of the menu-button-item-action
         */
        "icon"?: string;
        /**
          * The name of the item, usefull in order to identify the selected item
         */
        "name"?: string;
        /**
          * Weather the button is selected
          * @default false
         */
        "selected"?: boolean;
        /**
          * Tooltip text
         */
        "tooltipText"?: string;
    }
    interface AthMenuLateralItemLink {
        /**
          * The aria-label of the item
         */
        "ariaLabel"?: string | null;
        /**
          * The accesible label of the badge
         */
        "badgeLabel"?: string;
        /**
          * The maximum value inside the badge
         */
        "badgeMax"?: number;
        /**
          * The value inside the badge
         */
        "badgeValue"?: number;
        /**
          * Weather the button is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The text that indicates that the link open a new window
          * @default 'Se abre en una nueva ventana'
         */
        "externalLabel"?: string;
        /**
          * The URL of the link
         */
        "href"?: string;
        /**
          * The icon of the menu-button-item-link
         */
        "icon"?: string;
        /**
          * The name of the item, usefull in order to identify the selected item
         */
        "name"?: string;
        /**
          * The rel of the link
         */
        "rel"?: string;
        /**
          * Weather the button is selected
          * @default false
         */
        "selected"?: boolean;
        /**
          * The target of the link
          * @default TargetType.Self
         */
        "target"?: "self";
        /**
          * Tooltip text
         */
        "tooltipText"?: string;
    }
    interface AthMenuVertical {
        /**
          * Appearance of the menu
          * @default MenuVerticalAppearances.Primary
         */
        "appearance"?: MenuVerticalAppearance;
        /**
          * Emitted when link or action Button is clicked
         */
        "onAthSelected"?: (event: AthMenuVerticalCustomEvent<MenuItem>) => void;
    }
    interface AthMenuVerticalItemAction {
        /**
          * Whether the item is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Icon of the item
         */
        "icon"?: string;
        /**
          * Whether an item with children is open by default.
          * @default false
         */
        "open"?: boolean;
        /**
          * Whether the item is selected
          * @default false
         */
        "selected"?: boolean;
        /**
          * Title of the item
         */
        "text"?: string;
        /**
          * Value of the item, in order to identify it.
         */
        "value"?: string;
    }
    interface AthMenuVerticalItemLink {
        /**
          * Whether the link is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The text that indicates that the link open a new window
          * @default 'Se abre en una nueva ventana'
         */
        "externalLabel"?: string;
        /**
          * URL of the link
         */
        "href"?: string;
        /**
          * Icon of the item
         */
        "icon"?: string;
        /**
          * rel of the link
         */
        "rel"?: string;
        /**
          * Whether the link is selected
          * @default false
         */
        "selected"?: boolean;
        /**
          * target of the link: blank | self
          * @default menuItemLinkTargets.Blank
         */
        "target"?: menuItemLinkTarget;
        /**
          * Title of the link
         */
        "text"?: string;
        /**
          * Value of the item, in order to identify it.
         */
        "value"?: string;
    }
    interface AthModal {
        /**
          * Indicates the illustration used when the prop isAlert is set to true
          * @default ModalAppearance.Error
         */
        "appearance"?: ModalAppearanceType;
        /**
          * Indicates whether the modal should automatically focus the first interactive element
          * @default true
         */
        "autofocus"?: boolean;
        /**
          * Indicates whether the modal should close when clicking outside
          * @default false
         */
        "clickOutsideClose"?: boolean;
        /**
          * Accessible text for the close (X) button
         */
        "closeAriaLabel"?: string;
        /**
          * Indicates whether the modal will occupy the full screen
          * @default false
         */
        "fullScreen"?: boolean;
        /**
          * Indicates whether the modal has a close (X) button
          * @default true
         */
        "hasClose"?: boolean;
        /**
          * Indicates whether there is a divider between the header and the slots
          * @default false
         */
        "hasDivider"?: boolean;
        /**
          * Indicates the heading level of the title
          * @default 2
         */
        "headingLevel"?: number;
        /**
          * Indicates the title text
         */
        "headingText"?: string;
        /**
          * Indicates whether the modal has role "Alert", and interrupts the screen reader flow
          * @default false
         */
        "isAlert"?: boolean;
        /**
          * Indicates the maximum height of the modal
         */
        "maxHeight"?: string;
        /**
          * Indicates the maximum width of the modal
         */
        "maxWidth"?: string;
        /**
          * Emitted when the modal is closed
         */
        "onAthClosed"?: (event: AthModalCustomEvent<void>) => void;
        /**
          * Emitted when the modal is opened
         */
        "onAthOpened"?: (event: AthModalCustomEvent<void>) => void;
        /**
          * Indicates whether the modal is displayed by default
          * @default false
         */
        "open"?: boolean;
        /**
          * Differentiates the modal size between sm and md
          * @default ModalSize.Medium
         */
        "size"?: ModalSizeType;
        /**
          * Indicates the subtitle text
         */
        "subtitleText"?: string;
    }
    interface AthPagination {
        /**
          * ARIA label for the pagination component.
          * @default 'Paginación de resultados'
         */
        "athAriaLabel"?: string;
        /**
          * Current active page number in the pagination.
          * @default 1
         */
        "currentPage"?: number;
        /**
          * Determines whether the Pagination is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Defines the number of items displayed per page in the pagination.
         */
        "itemsPerPage"?: number;
        /**
          * Defines the selectable options for the number of items of the dropdown.
          * @default '[5, 10, 15]'
         */
        "itemsSelector"?: string;
        /**
          * Hide the buttons to navigate to the first and last pages.
          * @default false
         */
        "noEndButtons"?: boolean;
        /**
          * Determines whether the item count message is displayed in the pagination.
          * @default false
         */
        "noItemsCount"?: boolean;
        /**
          * Determines whether a dropdown is shown to select the number of items per page.
          * @default false
         */
        "noItemsSelector"?: boolean;
        /**
          * Hide the buttons to jump to the previous or next pages.
          * @default false
         */
        "noJumpButtons"?: boolean;
        /**
          * Event emitted when the items per page changes. Emits the new items per page as detail.
         */
        "onAthItemsPerPageChange"?: (event: AthPaginationCustomEvent<number>) => void;
        /**
          * Event emitted when the page changes. Emits the new page number as detail.
         */
        "onAthPaginate"?: (event: AthPaginationCustomEvent<number>) => void;
        /**
          * Total number of items over all pages.
         */
        "totalItems"?: number;
    }
    interface AthPanel {
        /**
          * Si el panel puede recibir el foco o no
          * @default false
         */
        "focusable"?: boolean;
        /**
          * Etiqueta accesible para el panel
         */
        "label"?: string;
    }
    interface AthPictogram {
        /**
          * The aria-label attribute of the pictogram
         */
        "ariaLabel"?: string | null;
        /**
          * The aria-labelledby attribute of the pictogram
         */
        "ariaLabelledby"?: string;
        /**
          * The pictogram name
         */
        "name"?: string;
        /**
          * The size of the pictogram
          * @default PictogramSizeType.Medium
         */
        "size"?: PictogramSizeTypes;
    }
    interface AthProgressBar {
        /**
          * Aria Label
         */
        "athAriaLabel"?: string;
        /**
          * Infinite determines if the progress bar is a loop or not
          * @default false
         */
        "infinite"?: boolean;
        /**
          * Change label alignment
          * @default ProgressBarLabelAlignment.Stack
         */
        "labelAlignment"?: ProgressBarLabelAlignmentType;
        /**
          * Text of the label left
         */
        "labelLeft"?: string;
        /**
          * Text of the label right
         */
        "labelRight"?: string;
        /**
          * Number max of progress bar
          * @default 100
         */
        "max"?: number;
        /**
          * Number min of progress bar
          * @default 0
         */
        "min"?: number;
        /**
          * Value of the progress bar
         */
        "value"?: number;
        /**
          * Value text of the progress bar
         */
        "valueText"?: string;
    }
    interface AthRadioButton {
        /**
          * Accessible text (aria-label)
         */
        "ariaLabel"?: string | null;
        /**
          * Indicates if it is checked by default
          * @default false
         */
        "checked"?: boolean;
        /**
          * Indicates if it is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Label text
         */
        "label"?: string;
        /**
          * Indicates the name of the radioButton
         */
        "name"?: string;
        /**
          * Emitted when the radio-button loses focus
         */
        "onAthBlur"?: (event: AthRadioButtonCustomEvent<void>) => void;
        /**
          * Emitted when there is a change in the input state
         */
        "onAthChange"?: (event: AthRadioButtonCustomEvent<RadioButtonChangeDetail>) => void;
        /**
          * Emitted when the radio-button receives focus
         */
        "onAthFocus"?: (event: AthRadioButtonCustomEvent<void>) => void;
        /**
          * Indicates if it is read-only
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Indicates the value of the radioButton
         */
        "value"?: string;
    }
    interface AthRadioButtonGroup {
        /**
          * Accessible name for the group
         */
        "ariaLabel"?: string | null;
        /**
          * Indicates whether the group is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Indicates the Feedback type
          * @default FeedbackTypes.None
         */
        "feedback"?: FeedbackType;
        /**
          * Feedback text to be displayed
         */
        "feedbackText"?: string;
        /**
          * Helper text to be displayed
         */
        "helperText"?: string;
        /**
          * Label text
         */
        "label"?: string;
        /**
          * Name attribute to apply to the whole group
         */
        "name"?: string;
        "onAthChangeValue"?: (event: AthRadioButtonGroupCustomEvent<string>) => void;
        /**
          * Indicates the orientation of the group
          * @default OrientationTypes.Vertical
         */
        "orientation"?: OrientationType;
        /**
          * Indicates whether the group is read-only
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Screen-reader-only text indicating the group is required
         */
        "requiredAriaLabel"?: string;
        /**
          * Indicates whether to show the asterisk
          * @default false
         */
        "showRequired"?: boolean;
        /**
          * Tooltip text
         */
        "tooltipText"?: string;
        /**
          * Tooltip width
          * @default 0
         */
        "tooltipWidth"?: number;
        /**
          * Set the value to select the checked ath-radio-button
         */
        "value"?: string;
    }
    interface AthSectionTitle {
        /**
          * 'The 'Section title' can become a button that shows or hides the content of the 'Collapse' component.
         */
        "collapsable"?: boolean;
        /**
          * Identifier of the 'Collapse' component whose visibility is controlled by this 'Section title'.
         */
        "collapseTarget"?: string;
        /**
          * Color assigned to the decorative element and the 'overline' text.
          * @default SectionTitleColor.Primary
         */
        "color"?: SectionTitleColorType;
        /**
          * Heading level assigned to the title. If 0, a <p> tag is assigned. Values between 1 and 6 correspond to <h1> ... <h6>.
          * @default 4
         */
        "headingLevel"?: number;
        /**
          * Heading level assigned to the overline. If 0, a <p> tag is assigned. Values between 1 and 6 correspond to <h1> ... <h6>.
          * @default 0
         */
        "headingOverline"?: number;
        /**
          * Indicates the heading size for the heading text.
          * @default HeadingSize.Sm
         */
        "headingSize"?: HeadingSizes1;
        /**
          * Section title.
         */
        "headingText"?: string;
        /**
          * The code of the Section Title's icon (used with type Icon)
         */
        "icon"?: string;
        /**
          * Emitted when the 'Collapse' component collapses or expands.
         */
        "onAthToggleCollapse"?: (event: AthSectionTitleCustomEvent<string>) => void;
        /**
          * Text above the title, usually used to categorize the content.
         */
        "overline"?: string;
        /**
          * The code of the Section Title's pictogram (used with type Pictogram)
         */
        "pictogram"?: string;
        /**
          * Tooltip text to be included.
          * @default ''
         */
        "tooltip"?: string;
        /**
          * Tooltip aria-label.
          * @default 'Más información'
         */
        "tooltipLabel"?: string;
        /**
          * Option assigned to the decorative element.
          * @default SectionTitleOption.Default
         */
        "type"?: SectionTitleOptionType;
    }
    interface AthSegmentedControl {
        /**
          * Text to show when the label of segmented control its not visible
         */
        "ariaLabel"?: string | null;
        /**
          * Color of the segmented control
          * @default SegmentedControlColors.Primary
         */
        "color"?: SegmentedControlColor;
        /**
          * The segmented control is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Type of feedback to show
          * @default SegmentedControlFeedbackType.None
         */
        "feedback"?: SegmentedControlFeedback;
        /**
          * Feedback text
         */
        "feedbackText"?: string;
        /**
          * Helper text for the segmented control
         */
        "helperText"?: string;
        /**
          * Show if is required in the label
          * @default false
         */
        "hideRequired"?: boolean;
        /**
          * Label text for the segmented control
         */
        "label"?: string;
        /**
          * The name of the segmented control to use with forms
         */
        "name"?: string;
        "onAthChangeValue"?: (event: AthSegmentedControlCustomEvent<HTMLAthSegmentedControlItemElement>) => void;
        /**
          * Show if is required
          * @default false
         */
        "required"?: boolean;
        /**
          * Show if is required in the label
         */
        "requiredAriaLabel"?: any;
        /**
          * Size of the segmented control
          * @default SegmentedControlSizes.Medium
         */
        "size"?: SegmentedControlSize;
        /**
          * Show the tooltip text
         */
        "tooltipText"?: string;
        /**
          * Show the width of the tooltip
          * @default 0
         */
        "tooltipWidth"?: number;
        /**
          * Types of the segmented control
          * @default SegmentedControlTypes.Select
         */
        "type"?: SegmentedControlType;
        /**
          * Set the value to select the checked ath-radio-button
         */
        "value"?: string;
    }
    interface AthSegmentedControlItem {
        /**
          * Size of the segmented control item
          * @default SegmentedControlColors.Primary
         */
        "color"?: SegmentedControlColor;
        /**
          * The segmented control is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The code of the button's icon (used with iconPosition)
         */
        "icon"?: string;
        /**
          * Icon position of the segmented control item
          * @default SegmentedControlItemIconPositions.None
         */
        "iconPosition"?: SegmentedControlItemIconPosition;
        /**
          * Emitted when the segmented control item is selected
         */
        "onAthChange"?: (event: AthSegmentedControlItemCustomEvent<SegmentedControlItemChangeSelect>) => void;
        /**
          * Emitted when the segmented control item is focus
         */
        "onAthFocus"?: (event: AthSegmentedControlItemCustomEvent<void>) => void;
        /**
          * The segmented control item is selected
          * @default false
         */
        "selected"?: boolean;
        /**
          * Size of the segmented control item
          * @default SegmentedControlSizes.Medium
         */
        "size"?: SegmentedControlSize;
        /**
          * The type of the control
          * @default SegmentedControlTypes.Select
         */
        "type"?: SegmentedControlType;
        /**
          * The value for a Segmented Control with type select (role radio)
         */
        "value"?: string;
    }
    interface AthSlider {
        /**
          * The ath-input-counter width.
          * @default 'auto'
         */
        "counterWidth"?: string;
        /**
          * Detail text at the left of the slider
         */
        "detailFirst"?: string;
        /**
          * Detail text at the right of the slider
         */
        "detailLast"?: string;
        /**
          * If true, the user cannot interact with the slider and the inputs.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The type of the feedback. If 'error' the error feedback will be shown.
          * @default SliderFeedbackTypes.None
         */
        "feedback"?: SliderFeedbackType;
        /**
          * Feedback error for input counter if is from, to, both or none.
          * @default SliderFeedbackErrorCounterTypes.None
         */
        "feedbackCounter"?: SliderFeedbackErrorCounterType;
        /**
          * The message for the feedback.
         */
        "feedbackText"?: string;
        /**
          * The aria-label attribute of the first input-counter.
         */
        "fromAriaLabel"?: string;
        /**
          * The aria-label attribute of the slider.
         */
        "groupAriaLabel"?: string;
        /**
          * Message to help the user fill the input value.
         */
        "helperText"?: string;
        /**
          * Label slider
         */
        "labelGroup"?: string;
        /**
          * Represents the maximum number of the input & slider.
          * @default 100
         */
        "max"?: number;
        /**
          * Represents the minimum number of the input & slider.
          * @default 0
         */
        "min"?: number;
        /**
          * The name of the slider. Submitted with the form as part of a name/value pair
         */
        "name"?: string;
        /**
          * Emitted when the slider loses focus
         */
        "onAthBlur"?: (event: AthSliderCustomEvent<void>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onAthChange"?: (event: AthSliderCustomEvent<string>) => void;
        /**
          * Emitted when the slider gains focus
         */
        "onAthFocus"?: (event: AthSliderCustomEvent<void>) => void;
        /**
          * If true, the user cannot modify the value.
          * @default false
         */
        "readonly"?: boolean;
        /**
          * If true, the user must fill in a value before submitting a form.
          * @default false
         */
        "required"?: boolean;
        /**
          * If true, the * asterisk will be show when required = true.
          * @default true
         */
        "showRequired"?: boolean;
        /**
          * Specifies the interval between legal numbers in an <input> element & slider.
          * @default 1
         */
        "step"?: number;
        /**
          * If true show step marks.
          * @default false
         */
        "stepped"?: boolean;
        /**
          * The aria-label attribute of the second input-counter.
         */
        "toAriaLabel"?: string;
        /**
          * Specifies text for tooltip.
         */
        "tooltipText"?: string;
        /**
          * The type of slider. if range shows two handles to select between two numbers.
          * @default SliderTypes.Default
         */
        "type"?: SliderType;
        /**
          * Specifies the unit for the input.
         */
        "unit"?: string;
        /**
          * Current value of the form control. Submitted with the form as part of a name/value pair.
          * @default this.min.toString()
         */
        "value"?: string;
        /**
          * The aria-valuetext attribute for slider.
         */
        "valueText"?: string;
        /**
          * Specifies the width for slider.
         */
        "width"?: string;
    }
    interface AthStep {
        /**
          * Defines the action text
         */
        "actionText"?: string;
        /**
          * Indicates the alignment of the step
         */
        "alignment"?: StepAlignmentType;
        /**
          * Defines the accessible message announced when the step changes to selected.Only applied on non-interactive steps
         */
        "ariaLiveMessage"?: string;
        /**
          * Defines the accessible text for the step
         */
        "athAriaLabel"?: string;
        /**
          * Identifies the step by its position in the list
         */
        "athId"?: number;
        /**
          * Indicates if the step is a button or a link
          * @default StepRole.Button
         */
        "athRole"?: StepRoleType;
        /**
          * Indicates if the step is interactive
         */
        "clickable"?: boolean;
        /**
          * Defines the accessible text for the chevron when its function is to collapse
         */
        "collapseLabel"?: string;
        /**
          * Defines the accessible text for the completed state
         */
        "completedLabel"?: string;
        /**
          * Indicates if the step is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the accessible text for the error indicator
         */
        "errorLabel"?: string;
        /**
          * Indicates the custom accessible text for the chevron to expand
         */
        "expandLabel"?: string;
        /**
          * Indicates if the step contains an error
          * @default StepFeedback.None
         */
        "feedback"?: StepFeedbackType;
        /**
          * Defines the title of the step
         */
        "headingText"?: string;
        /**
          * Indicates if the step is collapsable
          * @default false
         */
        "isCollapsable"?: boolean;
        /**
          * Indicates if the step is completed
          * @default false
         */
        "isComplete"?: boolean;
        /**
          * Indicates if the slot is expanded
          * @default false
         */
        "isExpanded"?: boolean;
        /**
          * Indicates the number of the step
         */
        "number"?: number;
        "onAthClick"?: (event: AthStepCustomEvent<number>) => void;
        /**
          * Indicates that the step is read-only
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Indicates that the step is in progress
         */
        "selected"?: boolean;
        /**
          * Sets the size of the step
         */
        "size"?: StepSizeType;
        /**
          * Indicates the total number of steps in the stepper
         */
        "total"?: number;
    }
    interface AthStepper {
        /**
          * Defines the message for screen readers when changing the step. Only applied on non-interactive steps
          * @default 'Paso actual [number]'
         */
        "ariaLiveMessage"?: string;
        /**
          * Defines the accessible text for the step
         */
        "athAriaLabel"?: string;
        /**
          * Indicates the role of the step
          * @default StepRole.Button
         */
        "athRole"?: StepRoleType;
        /**
          * Indicates if the steps are interactive
          * @default true
         */
        "clickable"?: boolean;
        /**
          * Indicates the custom accessible text for the chevron to collapse
          * @default 'Colapsar paso [number]'
         */
        "collapseLabel"?: string;
        /**
          * Specifies the accessible text for the CHECK indicator of completion, which will be injected into the steps
          * @default 'Completado'
         */
        "completedLabel"?: string;
        /**
          * Specifies the accessible text for the error indicator in steps
          * @default 'Error'
         */
        "errorLabel"?: string;
        /**
          * Indicates the custom accessible text for the chevron to expand
          * @default 'Expandir paso [number]'
         */
        "expandLabel"?: string;
        /**
          * Indicates the icon to use in the title
         */
        "headingIcon"?: string;
        /**
          * Indicates the title of the stepper
         */
        "headingText"?: string;
        "onAthSelect"?: (event: AthStepperCustomEvent<HTMLAthStepElement>) => void;
        /**
          * Indicates the orientation of the stepper
          * @default StepperOrientation.Horizontal
         */
        "orientation"?: StepperOrientationType;
        /**
          * Indicates if the all the steps are read-only
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Indicates the size of the steps
          * @default StepperSize.Medium
         */
        "size"?: StepperSizeType;
        /**
          * Indicates the number of the first step
          * @default 1
         */
        "startFrom"?: number;
    }
    interface AthSwitch {
        /**
          * Determines if the switch is disabled and cannot be interacted with
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Name to identify the switch
         */
        "name"?: string;
        /**
          * Event emitted when the switch loses focus
         */
        "onAthBlur"?: (event: AthSwitchCustomEvent<void>) => void;
        /**
          * Event emitted when the switch state changes
         */
        "onAthChange"?: (event: AthSwitchCustomEvent<SwitchChangeDetail>) => void;
        /**
          * Event emitted when the switch receives focus
         */
        "onAthFocus"?: (event: AthSwitchCustomEvent<void>) => void;
        /**
          * Makes the switch read-only, preventing user interaction while still being focusable
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Controls the selected/unselected state of the switch
          * @default false
         */
        "selected"?: boolean;
    }
    interface AthTab {
        /**
          * Si la tab está deshabilitada o no
         */
        "disabled"?: boolean;
        /**
          * Código del icono en caso de que la tab deba llevar icono
         */
        "icon"?: string;
        /**
          * Etiqueta accesible del icono
         */
        "iconAriaLabel"?: string;
        /**
          * Etiqueta accesible de la tab
         */
        "label"?: string;
        /**
          * Ruta de navegación de la tab
         */
        "navigationData"?: string;
        /**
          * Si la tab está seleccionada por defecto
         */
        "selected"?: boolean;
    }
    interface AthTable {
        /**
          * Enable clickable rows with action column
          * @default false
         */
        "clickable"?: boolean;
        /**
          * Table color
          * @default TableColor.Primary
         */
        "color"?: TableColorType;
        /**
          * Fix the first or last column
         */
        "frozen"?: TableFrozenType;
        /**
          * Hides select all checkbox when selectable is multiple
          * @default false
         */
        "noSelectAll"?: boolean;
        /**
          * Fired whenever row selection changes
         */
        "onAthSelectionChange"?: (event: AthTableCustomEvent<TableSelectionChangeEvent>) => void;
        /**
          * Fired when a clickable row is clicked
         */
        "onAthTableClick"?: (event: AthTableCustomEvent<TableClickEvent>) => void;
        /**
          * Row selection mode
          * @default TableSelectable.None
         */
        "selectable"?: TableSelectableType;
        /**
          * Row height
          * @default TableSize.Small
         */
        "size"?: TableSizeType;
        /**
          * Enable zebra striping
          * @default TableStriping.None
         */
        "striped"?: TableStripingType;
    }
    interface AthTableBody {
    }
    interface AthTableHeader {
        /**
          * Enable clickable rows with action column
          * @default false
         */
        "clickable"?: boolean;
        /**
          * Header color
          * @default TableColor.Primary
         */
        "color"?: TableColorType;
        /**
          * If the row has a fixed column, specify if it's the first or last column
          * @default TableFrozen.None
         */
        "frozen"?: TableFrozenType;
        /**
          * Hides select all checkbox when selectable is multiple
          * @default false
         */
        "noSelectAll"?: boolean;
        /**
          * Fired when select all checkbox state changes
         */
        "onAthSelectAllChange"?: (event: AthTableHeaderCustomEvent<TableSelectAllChangeEvent>) => void;
        /**
          * Current state of the select all checkbox (false | true | indeterminate)
          * @default CheckboxValue.False
         */
        "selectAllState"?: CheckboxValues;
        /**
          * Selection mode (none | single | multiple)
          * @default TableSelectable.None
         */
        "selectable"?: TableSelectableType;
        /**
          * Number of currently selected rows (used for determining indeterminate state)
          * @default 0
         */
        "selectedRows"?: number;
        /**
          * Header size
         */
        "size"?: TableSizeType;
        /**
          * Total number of selectable rows (used for determining indeterminate state)
          * @default 0
         */
        "totalRows"?: number;
    }
    interface AthTableHeaderItem {
        /**
          * Column alignment
         */
        "alignment"?: TableAlignmentType;
        /**
          * Column width (px, %, auto)
          * @default 'auto'
         */
        "cellWidth"?: string;
        /**
          * Item color
          * @default TableColor.Primary
         */
        "color"?: TableColorType;
        /**
          * If this column is fixed
         */
        "frozen"?: TableFrozenType;
        /**
          * If this column contains interactive elements (menus, buttons, links, etc.). This property will be passed down to all row items in the same column.
          * @default false
         */
        "hasInteractivity"?: boolean;
        /**
          * Item size
         */
        "size"?: TableSizeType;
    }
    interface AthTableRow {
        /**
          * Enable clickable functionality
          * @default false
         */
        "clickable"?: boolean;
        /**
          * Aria label of row click button
          * @default 'Navegar'
         */
        "clickableAriaLabel"?: string;
        /**
          * Row color
          * @default TableColor.Primary
         */
        "color"?: TableColorType;
        /**
          * Controls the expanded state for rows that have children
          * @default false
         */
        "expanded"?: boolean;
        /**
          * If the row has a fixed column, specify if it's the first or last column
          * @default TableFrozen.None
         */
        "frozen"?: TableFrozenType;
        /**
          * Whether this row has children
          * @default false
         */
        "hasChildren"?: boolean;
        /**
          * Indicates that this is the last visual row (no border). Internal use by ath-table
          * @default false
         */
        "last"?: boolean;
        /**
          * Emits when this clickable row is clicked
         */
        "onAthRowClick"?: (event: AthTableRowCustomEvent<TableRowClickEvent>) => void;
        /**
          * Emits when this row selection changes
         */
        "onAthRowSelectionChange"?: (event: AthTableRowCustomEvent<TableRowSelectionChangeEvent>) => void;
        /**
          * Optional parent row id if this row is a child
         */
        "parentId"?: string;
        /**
          * Reserve space for clickable column. Internal use by ath-table
          * @default false
         */
        "reserveClickable"?: boolean;
        /**
          * Reserve space for expander column even if this row has no children. Internal use by ath-table
          * @default false
         */
        "reserveExpander"?: boolean;
        /**
          * Unique id for this row
         */
        "rowId"?: string;
        /**
          * Selection mode (none | single | multiple)
          * @default TableSelectable.None
         */
        "selectable"?: TableSelectableType;
        /**
          * Current selection state
          * @default false
         */
        "selected"?: boolean;
        /**
          * Group name for radios in single mode
         */
        "selectionGroupName"?: string;
        /**
          * Row size
         */
        "size"?: TableSizeType;
        /**
          * Apply zebra striping
          * @default TableStriping.None
         */
        "striped"?: TableStripingType;
        /**
          * Optional row value to be included in selection events
         */
        "value"?: any;
    }
    interface AthTableRowItem {
        /**
          * Cell alignment
         */
        "alignment"?: TableAlignmentType;
        /**
          * Column width (px, %, auto)
          * @default 'auto'
         */
        "cellWidth"?: string;
        /**
          * Background color
          * @default TableColor.Primary
         */
        "color"?: TableColorType;
        /**
          * Current expanded state (used when expander = true)
          * @default false
         */
        "expanded"?: boolean;
        /**
          * Marks this cell as an expander control (collapse/expand). Internal use by ath-table-row.
          * @default false
         */
        "expander"?: boolean;
        /**
          * Aria-controls value for the expander button (ID of the collapsable content)
         */
        "expanderAriaControls"?: string;
        /**
          * If this cell is fixed, created a first or last column fixed
          * @default TableFrozen.None
         */
        "frozen"?: TableFrozenType;
        /**
          * If this cell contains interactive elements (menus, buttons, links, etc.). When true, row click events will be prevented to avoid conflicts with cell interactions.
          * @default false
         */
        "hasInteractivity"?: boolean;
        /**
          * Marks this cell as the first data cell of a child row (for indentation)
          * @default false
         */
        "isChild"?: boolean;
        /**
          * If this cell is header of the row
          * @default false
         */
        "isHeader"?: boolean;
        /**
          * If true, no shadow will be applied to the frozen cell
          * @default false
         */
        "noFrozenShadow"?: boolean;
        /**
          * Table size
         */
        "size"?: TableSizeType;
        /**
          * Striped background
          * @default false
         */
        "striped"?: boolean;
    }
    interface AthTabs {
        /**
          * Lista de tabs a generar
         */
        "items"?: TabItem[] | string;
        /**
          * Etiqueta accesible para la lista de tabs
         */
        "listAriaLabel"?: string;
        /**
          * Tipo de Tabs
          * @default TabsTypes.Underline
         */
        "type"?: TabsType;
    }
    interface AthTag {
        /**
          * Color del tag acompañando al propósito del mensaje
          * @default TAG_DEFAULT_COLOR
         */
        "color"?: TagColorTypes;
        /**
          * Texto que se visualiza dentro del tag
         */
        "headingText"?: string;
        /**
          * Icono
         */
        "icon"?: string;
        /**
          * Tamaño del tag
          * @default TAG_DEFAULT_SIZE
         */
        "size"?: TagSizes;
    }
    interface AthText {
        /**
          * Define color del texto: default, inverse, primary, accent, subtle
          * @default TextColor.Default
         */
        "color"?: AthTextColor;
        /**
          * Número de columnas y espaciado que se muestran
         */
        "columns"?: AthTextColumns | string;
        /**
          * Texto dentro del componente
         */
        "content"?: string;
        /**
          * Define semánticamente la jerarquías del texto: p, h1, h2, h3...
          * @default defaultAthTextModel.hierarchy
         */
        "hierarchy"?: 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
        /**
          * Número de líneas máximo a mostrar
         */
        "lines"?: number;
        /**
          * Mostrar tooltip con el contenido completo cuando el texto aparece truncado
         */
        "withTooltip"?: boolean;
    }
    interface AthTooltip {
        /**
          * The variant of the tooltip
          * @default TooltipColor.Primary
         */
        "color"?: TooltipColors;
        /**
          * Whether the tooltip has an arrow
          * @default true
         */
        "hasArrow"?: boolean;
        /**
          * The text in the tooltip
          * @default ''
         */
        "headingText"?: string;
        /**
          * Whether the tooltip has a maximum width, and if so, the maximum width
          * @default 240
         */
        "maxWidth"?: number;
        /**
          * The position of the tooltip
          * @default TooltipPosition.Right
         */
        "position"?: TooltipPositions;
        /**
          * The action that will show the tooltip
          * @default TooltipTrigger.Hover
         */
        "trigger"?: TooltipTriggers;
    }
    interface AthTooltipTrigger {
        /**
          * The aria-label attribute of the icon
          * @default 'Más información'
         */
        "ariaLabel"?: string | null;
        /**
          * The icon name
          * @default Icons.Info
         */
        "icon"?: string;
        /**
          * Emitted when the button loses focus
         */
        "onAthBlur"?: (event: AthTooltipTriggerCustomEvent<void>) => void;
        /**
          * Emitted when the button is clicked
         */
        "onAthClick"?: (event: AthTooltipTriggerCustomEvent<void>) => void;
        /**
          * Emitted when the button gains focus
         */
        "onAthFocus"?: (event: AthTooltipTriggerCustomEvent<void>) => void;
        /**
          * The size of the icon
          * @default 'md'
         */
        "size"?: IconSizeTypes;
    }
    interface AthUserDetail {
        /**
          * The aria-label attribute of the button-link.
         */
        "buttonAriaLabel"?: string;
        /**
          * If true, the user can click the button-link.
          * @default false
         */
        "clickable"?: boolean;
        /**
          * User Description.
         */
        "description"?: string;
        /**
          * User initials.
         */
        "initials"?: string;
        /**
          * Emmitted when button-link is clicked.
         */
        "onAthAction"?: (event: AthUserDetailCustomEvent<void>) => void;
        /**
          * Avatar SRC image.
         */
        "srcImage"?: string;
        /**
          * Type of avatar.
          * @default undefined
         */
        "type"?: UserDetailType;
        /**
          * User Name.
         */
        "userName"?: string;
    }
    interface AthUserMenu {
        /**
          * Initials to display in the avatar.
         */
        "initials"?: string;
        /**
          * Emitted when an item is clicked
         */
        "onAthAction"?: (event: AthUserMenuCustomEvent<{ item: HTMLAthMenuButtonItemElement }>) => void;
        /**
          * Indica si user-menu esta abierto
          * @default false
         */
        "open"?: boolean;
        /**
          * Define la src para imagen avatar
         */
        "srcImage"?: string;
        /**
          * Define el tipo de avatar
          * @default undefined
         */
        "type"?: UserMenuType;
        /**
          * Define el nombre del usuario
         */
        "userName"?: string;
    }
    interface IntrinsicElements {
        "ath-accordion": AthAccordion;
        "ath-accordion-item": AthAccordionItem;
        "ath-action-bar": AthActionBar;
        "ath-alert": AthAlert;
        "ath-avatar": AthAvatar;
        "ath-badge": AthBadge;
        "ath-breadcrumb": AthBreadcrumb;
        "ath-button": AthButton;
        "ath-button-expandable": AthButtonExpandable;
        "ath-button-link": AthButtonLink;
        "ath-calendar": AthCalendar;
        "ath-card": AthCard;
        "ath-card-header": AthCardHeader;
        "ath-card-selectable": AthCardSelectable;
        "ath-card-selectable-group": AthCardSelectableGroup;
        "ath-card-thumbnail": AthCardThumbnail;
        "ath-checkbox": AthCheckbox;
        "ath-checkbox-group": AthCheckboxGroup;
        "ath-chip-choice": AthChipChoice;
        "ath-chip-choice-group": AthChipChoiceGroup;
        "ath-chip-dismiss": AthChipDismiss;
        "ath-chip-dismiss-group": AthChipDismissGroup;
        "ath-collapse": AthCollapse;
        "ath-collapse-icon": AthCollapseIcon;
        "ath-datepicker": AthDatepicker;
        "ath-datepicker-range": AthDatepickerRange;
        "ath-divider": AthDivider;
        "ath-dropdown": AthDropdown;
        "ath-dropdown-option": AthDropdownOption;
        "ath-empty-state": AthEmptyState;
        "ath-icon": AthIcon;
        "ath-input-counter": AthInputCounter;
        "ath-input-password": AthInputPassword;
        "ath-input-text": AthInputText;
        "ath-input-textarea": AthInputTextarea;
        "ath-link": AthLink;
        "ath-list": AthList;
        "ath-list-item": AthListItem;
        "ath-menu-button": AthMenuButton;
        "ath-menu-button-item": AthMenuButtonItem;
        "ath-menu-horizontal": AthMenuHorizontal;
        "ath-menu-horizontal-item": AthMenuHorizontalItem;
        "ath-menu-lateral": AthMenuLateral;
        "ath-menu-lateral-item-action": AthMenuLateralItemAction;
        "ath-menu-lateral-item-link": AthMenuLateralItemLink;
        "ath-menu-vertical": AthMenuVertical;
        "ath-menu-vertical-item-action": AthMenuVerticalItemAction;
        "ath-menu-vertical-item-link": AthMenuVerticalItemLink;
        "ath-modal": AthModal;
        "ath-pagination": AthPagination;
        "ath-panel": AthPanel;
        "ath-pictogram": AthPictogram;
        "ath-progress-bar": AthProgressBar;
        "ath-radio-button": AthRadioButton;
        "ath-radio-button-group": AthRadioButtonGroup;
        "ath-section-title": AthSectionTitle;
        "ath-segmented-control": AthSegmentedControl;
        "ath-segmented-control-item": AthSegmentedControlItem;
        "ath-slider": AthSlider;
        "ath-step": AthStep;
        "ath-stepper": AthStepper;
        "ath-switch": AthSwitch;
        "ath-tab": AthTab;
        "ath-table": AthTable;
        "ath-table-body": AthTableBody;
        "ath-table-header": AthTableHeader;
        "ath-table-header-item": AthTableHeaderItem;
        "ath-table-row": AthTableRow;
        "ath-table-row-item": AthTableRowItem;
        "ath-tabs": AthTabs;
        "ath-tag": AthTag;
        "ath-text": AthText;
        "ath-tooltip": AthTooltip;
        "ath-tooltip-trigger": AthTooltipTrigger;
        "ath-user-detail": AthUserDetail;
        "ath-user-menu": AthUserMenu;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "ath-accordion": LocalJSX.AthAccordion & JSXBase.HTMLAttributes<HTMLAthAccordionElement>;
            "ath-accordion-item": LocalJSX.AthAccordionItem & JSXBase.HTMLAttributes<HTMLAthAccordionItemElement>;
            "ath-action-bar": LocalJSX.AthActionBar & JSXBase.HTMLAttributes<HTMLAthActionBarElement>;
            "ath-alert": LocalJSX.AthAlert & JSXBase.HTMLAttributes<HTMLAthAlertElement>;
            "ath-avatar": LocalJSX.AthAvatar & JSXBase.HTMLAttributes<HTMLAthAvatarElement>;
            "ath-badge": LocalJSX.AthBadge & JSXBase.HTMLAttributes<HTMLAthBadgeElement>;
            "ath-breadcrumb": LocalJSX.AthBreadcrumb & JSXBase.HTMLAttributes<HTMLAthBreadcrumbElement>;
            "ath-button": LocalJSX.AthButton & JSXBase.HTMLAttributes<HTMLAthButtonElement>;
            "ath-button-expandable": LocalJSX.AthButtonExpandable & JSXBase.HTMLAttributes<HTMLAthButtonExpandableElement>;
            "ath-button-link": LocalJSX.AthButtonLink & JSXBase.HTMLAttributes<HTMLAthButtonLinkElement>;
            "ath-calendar": LocalJSX.AthCalendar & JSXBase.HTMLAttributes<HTMLAthCalendarElement>;
            "ath-card": LocalJSX.AthCard & JSXBase.HTMLAttributes<HTMLAthCardElement>;
            "ath-card-header": LocalJSX.AthCardHeader & JSXBase.HTMLAttributes<HTMLAthCardHeaderElement>;
            "ath-card-selectable": LocalJSX.AthCardSelectable & JSXBase.HTMLAttributes<HTMLAthCardSelectableElement>;
            "ath-card-selectable-group": LocalJSX.AthCardSelectableGroup & JSXBase.HTMLAttributes<HTMLAthCardSelectableGroupElement>;
            "ath-card-thumbnail": LocalJSX.AthCardThumbnail & JSXBase.HTMLAttributes<HTMLAthCardThumbnailElement>;
            "ath-checkbox": LocalJSX.AthCheckbox & JSXBase.HTMLAttributes<HTMLAthCheckboxElement>;
            "ath-checkbox-group": LocalJSX.AthCheckboxGroup & JSXBase.HTMLAttributes<HTMLAthCheckboxGroupElement>;
            "ath-chip-choice": LocalJSX.AthChipChoice & JSXBase.HTMLAttributes<HTMLAthChipChoiceElement>;
            "ath-chip-choice-group": LocalJSX.AthChipChoiceGroup & JSXBase.HTMLAttributes<HTMLAthChipChoiceGroupElement>;
            "ath-chip-dismiss": LocalJSX.AthChipDismiss & JSXBase.HTMLAttributes<HTMLAthChipDismissElement>;
            "ath-chip-dismiss-group": LocalJSX.AthChipDismissGroup & JSXBase.HTMLAttributes<HTMLAthChipDismissGroupElement>;
            "ath-collapse": LocalJSX.AthCollapse & JSXBase.HTMLAttributes<HTMLAthCollapseElement>;
            "ath-collapse-icon": LocalJSX.AthCollapseIcon & JSXBase.HTMLAttributes<HTMLAthCollapseIconElement>;
            "ath-datepicker": LocalJSX.AthDatepicker & JSXBase.HTMLAttributes<HTMLAthDatepickerElement>;
            "ath-datepicker-range": LocalJSX.AthDatepickerRange & JSXBase.HTMLAttributes<HTMLAthDatepickerRangeElement>;
            "ath-divider": LocalJSX.AthDivider & JSXBase.HTMLAttributes<HTMLAthDividerElement>;
            "ath-dropdown": LocalJSX.AthDropdown & JSXBase.HTMLAttributes<HTMLAthDropdownElement>;
            "ath-dropdown-option": LocalJSX.AthDropdownOption & JSXBase.HTMLAttributes<HTMLAthDropdownOptionElement>;
            "ath-empty-state": LocalJSX.AthEmptyState & JSXBase.HTMLAttributes<HTMLAthEmptyStateElement>;
            "ath-icon": LocalJSX.AthIcon & JSXBase.HTMLAttributes<HTMLAthIconElement>;
            "ath-input-counter": LocalJSX.AthInputCounter & JSXBase.HTMLAttributes<HTMLAthInputCounterElement>;
            "ath-input-password": LocalJSX.AthInputPassword & JSXBase.HTMLAttributes<HTMLAthInputPasswordElement>;
            "ath-input-text": LocalJSX.AthInputText & JSXBase.HTMLAttributes<HTMLAthInputTextElement>;
            "ath-input-textarea": LocalJSX.AthInputTextarea & JSXBase.HTMLAttributes<HTMLAthInputTextareaElement>;
            "ath-link": LocalJSX.AthLink & JSXBase.HTMLAttributes<HTMLAthLinkElement>;
            "ath-list": LocalJSX.AthList & JSXBase.HTMLAttributes<HTMLAthListElement>;
            "ath-list-item": LocalJSX.AthListItem & JSXBase.HTMLAttributes<HTMLAthListItemElement>;
            "ath-menu-button": LocalJSX.AthMenuButton & JSXBase.HTMLAttributes<HTMLAthMenuButtonElement>;
            "ath-menu-button-item": LocalJSX.AthMenuButtonItem & JSXBase.HTMLAttributes<HTMLAthMenuButtonItemElement>;
            "ath-menu-horizontal": LocalJSX.AthMenuHorizontal & JSXBase.HTMLAttributes<HTMLAthMenuHorizontalElement>;
            "ath-menu-horizontal-item": LocalJSX.AthMenuHorizontalItem & JSXBase.HTMLAttributes<HTMLAthMenuHorizontalItemElement>;
            "ath-menu-lateral": LocalJSX.AthMenuLateral & JSXBase.HTMLAttributes<HTMLAthMenuLateralElement>;
            "ath-menu-lateral-item-action": LocalJSX.AthMenuLateralItemAction & JSXBase.HTMLAttributes<HTMLAthMenuLateralItemActionElement>;
            "ath-menu-lateral-item-link": LocalJSX.AthMenuLateralItemLink & JSXBase.HTMLAttributes<HTMLAthMenuLateralItemLinkElement>;
            "ath-menu-vertical": LocalJSX.AthMenuVertical & JSXBase.HTMLAttributes<HTMLAthMenuVerticalElement>;
            "ath-menu-vertical-item-action": LocalJSX.AthMenuVerticalItemAction & JSXBase.HTMLAttributes<HTMLAthMenuVerticalItemActionElement>;
            "ath-menu-vertical-item-link": LocalJSX.AthMenuVerticalItemLink & JSXBase.HTMLAttributes<HTMLAthMenuVerticalItemLinkElement>;
            "ath-modal": LocalJSX.AthModal & JSXBase.HTMLAttributes<HTMLAthModalElement>;
            "ath-pagination": LocalJSX.AthPagination & JSXBase.HTMLAttributes<HTMLAthPaginationElement>;
            "ath-panel": LocalJSX.AthPanel & JSXBase.HTMLAttributes<HTMLAthPanelElement>;
            "ath-pictogram": LocalJSX.AthPictogram & JSXBase.HTMLAttributes<HTMLAthPictogramElement>;
            "ath-progress-bar": LocalJSX.AthProgressBar & JSXBase.HTMLAttributes<HTMLAthProgressBarElement>;
            "ath-radio-button": LocalJSX.AthRadioButton & JSXBase.HTMLAttributes<HTMLAthRadioButtonElement>;
            "ath-radio-button-group": LocalJSX.AthRadioButtonGroup & JSXBase.HTMLAttributes<HTMLAthRadioButtonGroupElement>;
            "ath-section-title": LocalJSX.AthSectionTitle & JSXBase.HTMLAttributes<HTMLAthSectionTitleElement>;
            "ath-segmented-control": LocalJSX.AthSegmentedControl & JSXBase.HTMLAttributes<HTMLAthSegmentedControlElement>;
            "ath-segmented-control-item": LocalJSX.AthSegmentedControlItem & JSXBase.HTMLAttributes<HTMLAthSegmentedControlItemElement>;
            "ath-slider": LocalJSX.AthSlider & JSXBase.HTMLAttributes<HTMLAthSliderElement>;
            "ath-step": LocalJSX.AthStep & JSXBase.HTMLAttributes<HTMLAthStepElement>;
            "ath-stepper": LocalJSX.AthStepper & JSXBase.HTMLAttributes<HTMLAthStepperElement>;
            "ath-switch": LocalJSX.AthSwitch & JSXBase.HTMLAttributes<HTMLAthSwitchElement>;
            "ath-tab": LocalJSX.AthTab & JSXBase.HTMLAttributes<HTMLAthTabElement>;
            "ath-table": LocalJSX.AthTable & JSXBase.HTMLAttributes<HTMLAthTableElement>;
            "ath-table-body": LocalJSX.AthTableBody & JSXBase.HTMLAttributes<HTMLAthTableBodyElement>;
            "ath-table-header": LocalJSX.AthTableHeader & JSXBase.HTMLAttributes<HTMLAthTableHeaderElement>;
            "ath-table-header-item": LocalJSX.AthTableHeaderItem & JSXBase.HTMLAttributes<HTMLAthTableHeaderItemElement>;
            "ath-table-row": LocalJSX.AthTableRow & JSXBase.HTMLAttributes<HTMLAthTableRowElement>;
            "ath-table-row-item": LocalJSX.AthTableRowItem & JSXBase.HTMLAttributes<HTMLAthTableRowItemElement>;
            "ath-tabs": LocalJSX.AthTabs & JSXBase.HTMLAttributes<HTMLAthTabsElement>;
            "ath-tag": LocalJSX.AthTag & JSXBase.HTMLAttributes<HTMLAthTagElement>;
            "ath-text": LocalJSX.AthText & JSXBase.HTMLAttributes<HTMLAthTextElement>;
            "ath-tooltip": LocalJSX.AthTooltip & JSXBase.HTMLAttributes<HTMLAthTooltipElement>;
            "ath-tooltip-trigger": LocalJSX.AthTooltipTrigger & JSXBase.HTMLAttributes<HTMLAthTooltipTriggerElement>;
            "ath-user-detail": LocalJSX.AthUserDetail & JSXBase.HTMLAttributes<HTMLAthUserDetailElement>;
            "ath-user-menu": LocalJSX.AthUserMenu & JSXBase.HTMLAttributes<HTMLAthUserMenuElement>;
        }
    }
}
